<div style="page-break-before:always;">
</div>

# <a name="natch_additional"></a>7. Дополнительные возможности Natch
## <a name="taint_log"></a>7.1. Подробная трасса помеченных данных

Для более детального анализа может потребоваться больше информации, которую можно получить с помощью опции конфигурационного файла *Modules/log*.

В генерируемом логе на каждое обращение к помеченной памяти формируется расширенный набор данных.

Фрагмент лога для одного обращения:
```text
Load:
Process name: wget2 cr3:  0x1b5a5c000
Tainted access at 00007f921af88896
Access address 0x7f921a504b08 size 8 taint 0xfcfcfcfc
icount: 21216379863
Module name: /lib/x86_64-linux-gnu/libpthread.so.0 base:  0x00007f921af77000
Call stack:
    0: 00007f921af88896 in func 00007f921b3b1c40 wget2/build/lib/libwget.so.1::.recvfrom
    1: 00007f921b3c5307 wget2/libwget/net.c:861 in func 00007f921b3b0860 wget2/build/lib/libwget.so.1::.wget_tcp_read
    2: 00007f921b3bdbda wget2/libwget/http.c:990 in func 000055b58a29f350 files/wget2::.wget_http_get_response_cb
    3: 000055b58a2ac0ec wget2/src/wget.c:4017 in func 000055b58a2ac0e0 files/wget2::http_receive_response wget2/src/wget.c:4016
    4: 000055b58a2ac654 wget2/src/wget.c:2266 in func 000055b58a2ac2b0 files/wget2::downloader_thread wget2/src/wget.c:2250
    5: 00007f921af7efa1 in func 00007f921af7eeb0 /lib/x86_64-linux-gnu/libpthread.so.0
    6: 00007f921aeaf4cd
```
Не рекомендуется включать эту опцию по умолчанию, поскольку файл получается ощутимого размера
(сотни байт на каждое обращение к помеченным данным).

## <a name="taint_params_log"></a>7.2. Получение областей помеченной памяти для функций

Инструмент позволяет получить лог вызовов функций с диапазонами адресов записанных и прочитанных помеченных данных. Для получения лога необходимо использовать опцию конфигурационного файла *Modules/params_log*. Эта опция задает имя файла, куда будет записан лог с параметрами функций.

Выходной файл содержит диапазоны адресов и типы операций, выполненных с помеченными данными (r=чтение, w=запись). Также выводится стек вызовов на момент выхода из функции.

Фрагмент выходного файла:

```text
0xffffffff82dfc6f0 vmlinux:eth_type_trans
    0xffff88800e723840 8 bytes r
    0xffff88800e72384c 2 bytes r
    enter_icount: 58799550862
    exit_icount: 58799551027
    0: ffffffff82dfc963 in func ffffffff82dfc6f0 vmlinux::eth_type_trans
    1: ffffffff827cd3b6 in func ffffffff827ccec0 vmlinux::e1000_clean_rx_irq
    2: ffffffff827d544c in func ffffffff827d4c50 vmlinux::e1000_clean
    3: ffffffff82d1ea25 in func ffffffff82d1e6c0 vmlinux::net_rx_action
    4: ffffffff83a001b0 in func ffffffff83a00000 vmlinux::__do_softirq
    5: ffffffff83800f8d
0xffffffff81232e20 vmlinux:lock_acquire
    0xffff88806d009a90 8 bytes rw
    enter_icount: 58799552881
    exit_icount: 58799554333
    0: ffffffff81232ffd in func ffffffff81232e20 vmlinux::lock_acquire
    1: ffffffff8302c830 in func ffffffff8302c670 vmlinux::inet_gro_receive
    2: ffffffff82d200cb in func ffffffff82d1f440 vmlinux::dev_gro_receive
    3: ffffffff82d22885 in func ffffffff82d22680 vmlinux::napi_gro_receive
    4: ffffffff827cd485 in func ffffffff827ccec0 vmlinux::e1000_clean_rx_irq
    5: ffffffff827d544c in func ffffffff827d4c50 vmlinux::e1000_clean
    6: ffffffff82d1ea25 in func ffffffff82d1e6c0 vmlinux::net_rx_action
    7: ffffffff83a001b0 in func ffffffff83a00000 vmlinux::__do_softirq
    8: ffffffff83800f8d
```

## 7.3. Получение графов взаимодействий процессов и модулей

*Natch* позволяет получить историю распространения помеченных данных между процессами. Каждая строка лог-файла описывает передачу данных между двумя процессами, либо между процессом и файлом.

Для определения взаимодействий *Natch* выделяет дополнительную теневую память объемом в два раза больше, чем объем основной памяти, выделенной гостевой системе. В эту память для каждого физического адреса записывается идентификатор процесса, который последним записал помеченные данные на этот адрес. Взаимодействие определяется, когда процесс читает помеченные данные из ячейки памяти, записанной другим процессом. Взаимодействия также имеют веса, соответствующие количеству передаваемых данных. Однако следует отметить, что случаи, когда процесс читает 100 байт другого
процесса и когда читает 1 байт 100 раз, имеют один и тот же вес.

Также *Natch* умеет определять некоторые интерфейсы передачи данных. По системным вызовам отслеживаются взаимодействия процессов с файлами и сокетами. Через структуры ядра определяются области разделяемой и приватной памяти.

Для включения функции построения графов используется секция *TaintedTask* в основном конфигурационном файле. Опция *task_graph* отвечает за граф процессов, опция *module_graph* за граф модулей. Граф модулей строится теми же методами, что и граф процессов. Заметим, что включение обеих опций одновременно приведет к значительному увеличению объема потребления памяти. Результаты записываются соответственно в файлы *task_graph.json* и *module_graph.json* при завершении работы эмулятора.

Выходной файл на верхнем уровне представляет собой список ребер графа. У каждого ребра есть поля *source*, *destination* и *score*. Первые два описывают узлы, между которыми происходит передача помеченных данных. Поле *score* содержит количество передаваемых байт между процессами. Если граф строился во время воспроизведения, то для каждого ребра присутствует поле *icount*, которое описывает диапазон времени, в которое происходила передача данных. У некоторых ребер присутствует поле *extra*, которое содержит описание способа передачи данных. Описание способа передачи состоит из одного поля *type*, которое может принимать значения *shared-memory* для передач через разделяемую память и *private-memory* для передач через приватную память (Например, передача данных от родительского процесса к дочернему во время вызова fork). Описание узла графа имеет поле *type*, описывающее тип узла. Если узел является источником помеченных данных, то его описание содержит поле *taint_source* в значении *true*. Далее идет описание каждого типа узлов графа и его параметров:

* *file* - обычный файл. Поле *name* содержит полное имя файла.
* *tcp*, *udp*, *tcpv6*, *udpv6* - сетевые сокеты TCP и UDP для IPv4 и IPv6 соответственно. Поля ip и port содержат соответственно ip адрес и порт сокета.
* *unix* - unix сокет. Поле *name* содержит имя файла из параметров сокета, либо строку *pair + число*, если сокет не имеет имени файла (Создан системным вызовом *socketpair*)
* *netlink* - netlink сокет. Поле *name* содержит индивидуальный адрес сокета netlink.
* *socket* - остальные виды сокетов. Поле *name* содержит название типа сокета. Наличие такого узла в графе говорит о том, что обработка параметров данного типа сокетов в настоящее время не реализована.
* *pipe* - неименованный канал. Поле *name* содержит строку *pair + число*.
* *network* - сеть, источник помеченных данных. Поле *protocol* описывает номер ip протокола в сетевых пакетах. Поле *port_in* описывает входящий порт, поле *port_out* исходящий порт.
* *user-process* - пользовательский процесс. Поле proc содержит уникальный id процесса.
* *kernel-process* - процесс ядра. Поля совпадают с *user-process*.
* *module* - модуль (Только для *module_graph*). Поле *name* содержит имя модуля, поле *address* - адрес модуля.
* *kernel* - ядро в *module_graph*. При наличии отладочных символов поле *name* содержит имя исполняемого файла ядра.

Пример выходного файла:

```text
{"icount": {"start": 13557580656, "final": 13557582746}, "source": {"port": 80, "ip": "172.217.168.228", "type": "tcp", "id": 219}, "destination": {"proc": 20, "type": "user-process"}, "score": 1642},
{"icount": {"start": 14161961429, "final": 14161966494}, "source": {"proc": 20, "type": "user-process"}, "destination": {"name": "/home/nat/bin/scripts/index.html", "type": "file", "id": 2035}, "score": 2058},
{"icount": {"start": 14161961429, "final": 14161966494}, "source": {"name": "/home/nat/bin/scripts/index.html", "type": "file", "id": 2035}, "destination": {"proc": 196, "type": "user-process"}, "score": 2048},
{"icount": {"start": 14167892352, "final": 14167896186}, "extra": {"type": "shared-memory"}, "source": {"proc": 196, "type": "user-process"}, "destination": {"proc": 198, "type": "user-process"}, "score": 100},
```

## <a name="functional_coverage"></a>7.4. Анализ покрытия бинарного кода

Плагин *coverage* используется для сбора покрытия исполняемого кода.

Опции плагина:

- *file* -
Задаёт название файла, куда будут записываться данные о покрытии кода (по умолчанию *coverage.cov64*)
- *taint* - Позволяет переключать режимы сбора покрытия. Если установлено значение *true*, то плагин будет собирать данные о покрытии только для помеченных данных. Если значение параметра не установлено или установлено в *false*, плагин будет собирать данные о покрытии для всех базовых блоков, которые были выполнены и относятся к какому-либо модулю (данный плагин не собирает покрытия для базовых блоков, которые не относятся ни к одному модулю).
- *txt* - Предоставляет возможность выбора формата сохранения данных о покрытии кода. Если значение установлено в *true*, данные сохраняются в текстовом формате. Если значение не указано или установлено в *false*, данные сохраняются в бинарном формате.

Для активации данного плагина необходимо раскомментировать секцию *[Coverage]* в главном конфигурационном файле *Natch* и присвоить значения указанным выше параметрам.

Для удобного анализа бинарного выходного файла можно воспользоваться скриптом *coverage.py*, который раскрашивает выполненный код в IDA Pro и выводит таблицу с покрытием функций. На данный момент скрипт протестирован и гарантированно работает на версиях 7.2 и 7.6, теоретически и на тех, что между ними.

Чтобы использовать скрипт *coverage.py*, необходимо:

1. Открыть интересующий двоичный файл в IDA Pro.
2. Для совпадения адресов в Qemu и IDA Pro необходимо выполнить Rebase (Edit -> Segments -> Rebase program). Рекомендуется использовать адрес начала модуля.
3. Запустить выполнение скрипта *coverage.py* (File -> Script file).
4. Выбрать файл с интересующим покрытием в формате *.cov64*.
5. В появившемся окне выбрать интересующие процессы.


## <a name="func_args"></a>7.5. Получение аргументов вызываемых функций

*Natch* предоставляет бета-возможность получения корпуса данных для фаззинга. На данный момент поддерживаются только простые типы аргументов, а именно, целочисленные значения, числа с плавающей запятой и null-терминированные строки (char \*). Если встречается аргумент, не соответствующий этим требованиям, то возможны два сценария: если аргумент был передан по ссылке или является указателем, то он будет пропущен и анализ будет продолжен; в противном случае, он и все последующие аргументы не будут проанализированы.

Для включения этой возможности необходимо раскомментировать секцию *[FunctionArgs]* в главном конфигурационном файле *Natch*, где в поле *config* следует указать имя конфигурационного файла с подобным содержимым:

```
[Func1]
name=check_result

[Func2]
name=do_curl
```
Вышепредставленный конфигурационный файл на данный момент не генерируется автоматически, а должен быть создан пользователем вручную. В примере *check_result* и *do_curl* это названия функций, для которых будут собираться значения аргументов. Созданный конфигурационный файл следует поместить в папку со сценарием, а в основном конфигурационном файле написать имя без пути (таким образом, можно использовать разные конфиги в разных сценариях, не изменяя основной конфигурационный файл).
Фрагмент основного конфигурационного файла:
```
[FunctionArgs]
config=functions.cfg
```

Если список функций заранее известен, то *Natch* можно запустить в облегченном варианте без отслеживания помеченных данных, для этого в секции *[Taint]* параметр *on* следует установить в *false*, таким образом, замедление будет минимизировано. Результат работы механизма будет помещен в папку *output* в виде json файла с именем *args_info*.

В противном случае потребуется два запуска *Natch*: первый с целью анализа и выявления интересующих функций, а второй уже непосредственно для получения аргументов.

Пример полученного результата для тестового сценария *sample_test*:
```
[
    {
        "Function name": "check_result",
        "Arguments": [
            {
                "Name": "res",
                "Type": "signed int",
                "Value": "47270"
            }
        ]
    },
    {
        "Function name": "do_curl",
        "Arguments": [
            {
                "Name": "str",
                "Type": "char *",
                "Value": "www.google.com"
            }
        ]
    }
]
```

## <a name="taint_sockets"></a>7.6. Пометка сокетов

В *Natch* реализована возможность пометки локальных сокетов. Для этого используется поле *list* (то же что и для пометки файлов) в секции *TaintFile* конфигурационного файла помеченных данных. Чтобы помечать сокеты, следует указать название нужного протокола в качестве имени файла (например, TCP, UDP, TCPv6, UDPv6, UNIX). Это имена, которые присваиваются файлам сокетов самим ядром Linux.

По умолчанию будет выполняться пометка всех сокетов указанного протокола. Чтобы уточнить параметры сокета, нужно поставить вертикальную черту в конце имени файла и указать эти параметры в определенном виде.

Для сетевых сокетов указывается ip адрес в традиционной форме записи IPv4 или IPv6 (например, 127.0.0.1 и ::FFFF:10.0.2.2). Через пробел опционально указывается порт сокета.
Подразумевается, что эти адрес и порт относятся к месту назначения, с которым данный сокет взаимодействует. Пометка по параметрам "слушающих" сокетов на текущий момент не реализована, поэтому при необходимости помечать сокеты, создаваемые сервером для каждого клиента, необходимо указать выдаваемые им системой номера портов.

Для unix сокетов после вертикальной черты указывается соответствующее их адресу имя файла или уникальная строка. Указать для пометки конкретный безымянный unix сокет на текущий момент не представляется возможным.

Ниже приведен пример секции *TaintFile* с указанными сокетами:

```ini
[TaintFile]
list=TCP|173.194.220.105 80;UDP|127.0.0.1;UNIX|server123.sock;UDPv6|2a00:1450:4010:c0f::69
```
