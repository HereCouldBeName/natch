<div style="page-break-before:always;">
</div>

# <a name="natch_run_main"></a>5. Запуск Natch

Для использования инструмента следует установить *Natch* и зависимости (подробнее в разделе [Установка и настройка Natch](3_setup.md#setup_natch)).

## 5.1. Режимы работы Natch

*Natch* предусматривает два режима работы: облегченный и стандартный. Облегченный режим предполагает отключение анализа помеченных данных,
за счет чего выполнение сценария происходит быстрее. В этом режиме осуществляется сбор информации о процессах, модулях, файлах, сетевых взаимодействиях.
Предполагается, что облегченный режим может быть использован для получения общей картины происходящего в системе, получения информации о том, что требуется пометить
с целью проведения уже полноценного анализа (стандартный режим).

Переключение режимов осуществляется с помощью скрипта *change_setting.py*, входящего в поставку. Подробное описание представлено в разделе [Внесение изменений в скрипты запуска](#natch_change_settings).

## <a name="natch_run_script"></a>5.2. Использование скрипта для генерации командных строк запуска

В поставку инструмента входит скрипт *natch_run.py*, который нужен для генерации командных строк для запуска *Natch*, а так же для первоначальной настройки инструмента. Скрипт *natch_run.py* расположен в директории *natch_scripts*. Запускать скрипт можно из любого расположения, готовые скрипты для запуска инструмента и все конфигурационные файлы будут помещены в рабочей директории, указанной пользователем или назначенной автоматически.

В процессе выполнения скрипта пользователь должен уточнять параметры запуска инструмента. На выходе сформируются три скрипта: *run_record.sh* и *run_replay.sh* для запуска *Natch* в режиме записи и
воспроизведения работы соответственно, а так же *run_qemu.sh* для запуска Qemu без *Natch*.

Скрипт *natch_run.py* имеет три параметра, один обязательный и два опциональных. Обязательный параметр это путь к образу системы, опциональные - путь к ядру (опция kernel эмулятора Qemu, если ядро ОС не загружается из образа системы) и название операционной системы, для которой будет использован инструмент (по умолчанию Linux, предоставляется выбор из следующих вариантов: Linux, FreeBSD, Win7, Win8, Win11). Так же скрипт можно запустить с опцией *-h* и получить справку по доступным опциям.

Описание команды и ее параметров представлено ниже:
```text
natch_run.py image [-h] [-k KERNEL] [-o {Linux, FreeBSD, Win7, Win8, Win10}]
```
Пример запуска скрипта:
```bash
./natch_run.py <image> -o Linux
```

Список вопросов, которые будут заданы при выполнении скрипта:

- *Путь к директории проекта* \
Необходимо указать полный путь или только название папки, которая будет создана для хранения всех скриптов, конфигураций и прочих файлов инструмента.
Параметр является опциональным, в случае пропуска рабочий каталог будет называться именем запускаемого образа гостевой системы.
Если каталог уже существует, будет создан новый с постфиксом *_х*, где x - это число от 1 до максимально возможного.

- *Количество оперативной памяти* \
Необходимо указать объем оперативной памяти, выделяемый виртуальной машине. Указывается число в гигабайтах или мегабайтах с соответствующим постфиксом G или M, например 512M.

- *Режим работы эмулятора* \
Эмулятор может быть запущен в графическом (обычном) или текстовом режиме. По умолчанию режим графический, если же необходимо работать в тестовом режиме следует дать ответ *n* или *N*. В этом случае потребуется дополнительная настройка вашего образа (в тестовом все настроено).

После этих вопросов скрипт попробует обратиться к утилите *natch-qemu-img*, входящей в поставку *Natch*, чтобы проверить ее доступность, так как она будет нужна при записи сценариев.

- *Сетевые опции* \
В этом меню пользователь может указать порты, которые необходимо пробросить в виртуальную машину. Запрос на ввод портов появится при выборе ответа *Y/y* или при нажатии клавиши *Enter*. Кроме того, будет предложено помечать не только Destination ports, но и Source. Если это необходимо, следует выбрать ответ *Y/y* или нажать клавишу *Enter*. Порты следует указывать через запятую. На каждый указанный порт будет назначен порт для обращения к машине извне, формироваться они будут следующим образом: первый порт из динамического диапазона для первого пользовательского порта, для остальных путем прибавления единицы. Например, пользователь ввел порты 7777, 8888, получим 49152 и 49153 соответственно.

- *Создание конфигурационного файла для модулей* \
Если модули есть в наличии, то следует нажать *Enter*, *y* или *Y*, в противном случае ввести *n* или *N*. Если конфигурационный файл нужен, будет предложено ввести путь к папке, содержащей модули. Так как генерация конфигурационного файла может занять продолжительное время, этот процесс будет запущен параллельно. По окончании настроек будет предложено или ознакомиться с логом процесса генерации или подождать завершения процесса, а уже затем ознакомиться с логом (если сообщения о просмотре лога не будет, значит он пустой и все прошло великолепно).

- *Генерация конфигурационного файла для ядерных сущностей* \
Следующий вопрос коснется конфигурационного файла *task.cfg*. Если вы впервые создаете конфигурацию для образа, следует воспользоваться ответом по умолчанию (да). На этом этапе будет запущен эмулятор для извлечения информации о структурах ядра. Если же вы уже работали с этим образом и получали конфигурационный файл с этого этапа - вопрос можно пропустить, но не забудьте скопировать *task.cfg* в рабочую директорию нового проекта. Если не уверены, что файл от нужного образа - лучше ответить да и дождаться генерации файла.

Если конфигурационный файл для модулей не успел построиться к этому моменту, будет выведено сообщение `Waiting for module config generating`. Следует дождаться окончания работы скрипта. Если в процессе генерации файла происходили какие-то нештатные события, будет предложено ознакомиться с логом.

- *Символьная информация* \
Далее пользователю предложат скачать отладочные символы для системных библиотек, от которых зависит его приложение, и символы ядра операционной системы. Для выполнения этой операции потребуется пароль для sudo. В случае нештатных ситуаций пользователь получит соответствующие сообщения, а произвести скачивание символов можно будет отдельно, воспользовавшись скриптом ``debug_info.py`` (подробнее в пункте [Автоматическая загрузка отладочной информации для разделяемых библиотек](4_configs.md#debug_info)). Если не было выбрано создание конфигурационного файла для модулей, то на этом этапе будут скачаны только модули ядра.

Затем произойдет извлечение символьной информации для скачанных модулей.

На этом настройка окончена.

Кроме командных строк будет сгенерирована заготовка конфигурационного файла *Natch*. В полученном файле описаны все возможные секции и поля с примерами заполнения,
часть из которых закомментирована. При необходимости этот файл можно отредактировать - раскомментировать нужные секции и внести актуальные значения параметров.
Имя конфигурационного файла задается по умолчанию, а именно *natch.cfg*.

Полученные скрипты *run_record.sh* и *run_replay.h* применяются для работы с *Natch* для записи сценария работы виртуальной машины и воспроизведения соответственно.

С версии *Natch 2.3* предусмотрена работа с несколькими сценариями в рамках одного проекта, в связи с чем в скрипты записи и воспроизведения добавился некоторый интерактив.

При запуске скрипта *run_record.sh* будет запрошено имя сценария. В случае пропуска поля ввода, имя будет назначено автоматически (*record*).
Обратите внимание, что при указании одинаковых имен сценарии будут перезаписаны. Сценарии располагаются в отдельных папках с указанными пользователем названиями.
В каждую такую папку помещаются все необходимые для работы сценария файлы - журнал, оверлей, конфигурационный файл для помеченных данных, логи сетевых взаимодействий и т.д.
Именно в папке со сценарием будет находиться вторая часть основного конфигурационного файла (*taint.cfg*), который следует отредактировать перед воспроизведением.

При запуске скрипта *run_replay.sh* ситуация может разворачиваться несколькими способами:

* *У нас один сценарий и один снапшот*. В этом случае воспроизведение запустится и отработает без участия пользователя.
* *У нас один сценарий и несколько снапшотов*. Сценарий будет выбран по умолчанию, а для загрузки нужного снапшота нужно будет выбрать его из меню (с помощью стрелочек и клавиши Enter).
* *У нас несколько сценариев и один снапшот (для выбранного сценария)*. Для выбора сценария будет отображено меню с доступными сценариями, снапшот загрузится автоматически.
* *У нас несколько сценариев и несколько снапшотов (для выбранного сценария)*. В обоих случаях будет отображено меню.

Помимо этого скрипт *run_replay.sh* имеет два необязательных параметра *scenario_name* и *snapshot_name*. Например, если во время записи был создан сценарий с названием *sample* и в процессе работы был сохранен снапшот с именем *state*, то запустить воспроизведение с этого момента можно передав скрипту параметры ``./run_replay.sh sample state``. Обратите внимание, что требуется указывать оба параметра, в противном случае они будут проигнорированы, и скрипт будет вести себя как описано выше. Если во время работы снапшот не был сохранен, то следует указать имя стартового снапшота, а именно *init*.

В процессе работы скрипта *natch_run.py* вызывается ряд других скриптов, входящих в поставку *Natch*. Если на каком-то из этапов что-то пошло не так или пользователь отказался от какой-то опции а потом передумал, эти скрипты можно запускать самостоятельно. Все они оснащены опцией *-h* для получения справки о параметрах. Далее приведено краткое описание скриптов:

- *module_config.py* - генерирует конфигурационный файл *module.cfg*
- *debug_info.py* - скачивает символьную информацию для модулей и ядра, модифицирует *module.cfg*, на вход принимает его же.
- *symbol_info.py* - парсит символьную информацию, формирует базу символов. Так же требуется *module.cfg*.


### <a name="natch_append_modules"></a>5.2.1. Пополнение конфигурационного файла module.cfg

При работе с инструментом может возникнуть желание дополнить список модулей, указанных при настройке проекта. 
Для этого можно использовать скрипт `append_module_config.py`, расположенный в папке `utils` (полный путь: `/usr/bin/natch/bin/natch_scripts/utils`).

```bash
append_module_config.py [-h] [-d WORKDIR] -D MODULEDIR -i IMAGE
```
Скрипт потребует два обязательных параметра: путь к директории с новыми модулями (`-D`), а так же образ, используемый в проекте (`-i`), для скачивания информации о зависимых библиотечных модулях.
Если скрипт запускается не из рабочей директории проекта, необходимо указать путь к ней, используя опциональный параметр `-d`.

В процессе работы скрипта будет проанализирован каталог с новыми модулями, исследованы зависимости и скачана информация о библиотечных модулях (если есть), а так же перестроена символьная информация.
Если на этапе конфигурирования проекта не была скачана отладочная информация для ядра и интерпретаторов, то здесь есть возможность это исправить (будет задан соответствующий вопрос).

Для работы потребуется пароль администратора для монтирования образа. На выходе получим новый `module.cfg` и обновленные каталоги с информацией о модулях.

### <a name="natch_change_settings"></a>5.2.2. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны следующие параметры: размер оперативной памяти, проброшенные порты, режим работы эмулятора и режим работы *Natch*.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS] [-t TEXT_MODE] [-M {light,normal}]
```
Все параметры являются опциональными. Параметр, отвечающий за режим работы *Natch*, не может быть использован в группе с другими параметрами, при их совместном использовании остальные параметры будут проигнорированы.

- Директория. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- Проброшенные порты. Указать список новых портов для проброса через запятую без пробелов. Прошлый список будет заменен. Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и конфигурационные файлы инструмента (при желании).
- Режим работы эмулятора. Предполагается два режима - графический и текстовый. Чтобы переключиться в текстовый режим следует использовать аргумент *yes*, в противном случае - *no*.
- Режим работы *Natch*. Доступно два режима - облегченный и стандартный (light и normal соответственно). 

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343 -t no
```
Такой запуск приведет к изменению скриптов запуска (`run_qemu.sh`, `run_record.sh`, `run_replay.sh`), а так же будет предложено выбрать в каких сценариях следует внести изменения и в конфигурационные файлы. Если такие изменения не требуются - нужно нажать клавишу *ESC*.

Изменение режима работы *Natch*:
```bash
./change_settings.py -M light
```
Выполнение скрипта с параметром *light* приведет к тому, что в основном конфигурационном файле будет отключено построение графов, а в конфигурационных файлах помеченных данных
для сценариев будут закомментированы источники пометки. Обратите внимание, что сценарии, для которых будет работать облеченный режим, будут предложены на выбор. В случае, если
конфигурационные файлы для сценариев не будут выбраны для изменений, пометки смогут просочиться и режим не будет полноценно облегченным. Если вы включаете облегченный режим работы до того как были
записаны сценарии, потом следует самостоятельно закомментировать источники пометки в файлах `taint.cfg` всех интересующих вас сценариев. 

Переключение в стандартный режим происходит аналогичным образом:
```bash
./change_settings.py -M normal
```
Однако, важно заметить, что конфигурационные файлы для сценариев изменены не будут, пользователю необходимо самостоятельно определить источники пометки.


## 5.3. Определение источников пометки
### 5.3.1. Пометка файлов

*Natch* может помечать отдельные файлы в гостевой системе и отслеживать модули и функции, которые были затронуты в результате работы с ними. При этом берутся в расчет только операции чтения.

Исполняемые файлы помечаться таким способом не будут, так как они не открываются для чтения пользовательским кодом, а отображаются
прямо в адресное пространство ядерными функциями.
Аналогично не будет детектироваться работа драйвера жесткого диска с местом хранения заданного файла.

Задать необходимые для пометки файлы можно в [конфигурационном файле для помеченных данных](4_configs.md#taint_config).


### 5.3.2. Пометка входящих сетевых пакетов

*Natch* способен помечать весь сетевой трафик, который приходит в виртуальную машину извне.
Пометка полностью локального трафика на данный момент осуществляется через пометку сокетов в секции *[TaintFile]* (подробнее в описании секции **TaintFile** [конфигурационного файла](4_configs.md#taint_config)).

Для управления пометкой пакетов используется секция *[Ports]* конфигурационного файла (подробнее в пункте [Конфигурационный файл для помеченных данных](4_configs.md#taint_config) секция **Ports**).

Пакеты помечаются целиком, вместе с заголовком второго уровня.
Для пометки можно фильтровать пакеты по протоколу 3 уровня или по выбранным портам,
если используются протоколы TCP или UDP. Список портов можно посмотреть в [википедии](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).

Возможны следующие варианты работы:

* Помечать все входные пакеты. ip_protocol=-1 + (dst=-1 или src=-1)
* Помечать все UDP-пакеты. ip_protocol=17 + (dst=-1 или src=-1)
* Помечать все TCP-пакеты. ip_protocol=6 + (dst=-1 или src=-1)
* Помечать все HTTP-пакеты от внешнего веб-сервера. ip_protocol=6 + src=80
* Помечать все SNMP-пакеты к внутреннему серверу. ip_protocol=17 + dst=161
* Помечать все ICMP-пакеты. ip_protocol=1
* Помечать другие IP-пакеты, относящиеся к выбранному протоколу 3 уровня. ip_protocol=*x*, где *x* можно взять из [таблицы](https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers)



