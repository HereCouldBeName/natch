<div style="page-break-before:always;">
</div>

# <a name="natch_run_main"></a>5. Запуск Natch

Для использования инструмента следует установить *Natch* и зависимости (подробнее в разделе [Установка и настройка Natch](3_setup.md#setup_natch)).

##  <a name="natch_mode">5.1. Режимы работы Natch

*Natch* предусматривает два режима работы: облегченный и стандартный. Облегченный режим предполагает отключение анализа помеченных данных,
за счет чего выполнение сценария происходит быстрее. В этом режиме осуществляется сбор информации о процессах, модулях, файлах, сетевых взаимодействиях.
Предполагается, что облегченный режим может быть использован для получения общей картины происходящего в системе, получения информации о том, что требуется пометить
с целью проведения уже полноценного анализа (стандартный режим).

Переключение режимов осуществляется с помощью основного конфигурационного файла (секция *[Mode]*). Подробнее в разделе [Основной конфигурационный файл](4_configs.md#main_config).

## <a name="natch_run_script"></a>5.2. Использование скрипта для генерации командных строк запуска

В поставку инструмента входит скрипт *natch_run.py*, который нужен для генерации командных строк для запуска *Natch*, а так же для первоначальной настройки инструмента. Скрипт *natch_run.py* расположен в директории *natch_scripts*. Запускать скрипт можно из любого расположения, готовые скрипты для запуска инструмента и все конфигурационные файлы будут помещены в рабочей директории, указанной пользователем или назначенной автоматически.

В процессе выполнения скрипта пользователь должен уточнять параметры запуска инструмента. На выходе сформируются три скрипта:
*run_record.sh* и *run_replay.sh* для запуска *Natch* в режиме записи и воспроизведения работы соответственно, а так же *run_qemu.sh* для запуска Qemu без *Natch*.

Скрипт *natch_run.py* имеет ряд параметров, один обязательный, остальные опциональные. Обязательный параметр это путь к образу системы, опциональные - путь к ядру (опция kernel эмулятора QEMU, если ядро ОС не загружается из образа системы), название операционной системы, для которой будет использован инструмент (по умолчанию Linux, предоставляется выбор из следующих вариантов: Linux, FreeBSD, Win7, Win8, Win10), путь к конфигурационному файлу с помощью которого можно автоматически создать проект с заданными характеристиками (подробнее в разделе
[Создание проекта с помощью конфигурационного файла](5_launch.md#natch_save_settings)). Так же скрипт можно запустить с опцией *-h* и получить справку по доступным опциям.

Описание команды и ее параметров представлено ниже:
```text
natch_run.py image [-h] [-k KERNEL] [-o {Linux, FreeBSD, Win7, Win8, Win10}] [-c CONFIG]
```
Пример запуска скрипта:
```bash
./natch_run.py <image> -o Linux
```

 Работа скрипта проходит в два этапа: на первом пользователю будет задан ряд вопросов, а затем действия будут происходить автоматически.
 Список вопросов, которые будут заданы при выполнении скрипта:

- *Путь к директории проекта* \
Необходимо указать название папки или полный путь к папке, которая будет создана для хранения всех скриптов, конфигураций и прочих файлов инструмента.
Параметр является опциональным, в случае пропуска рабочий каталог будет называться именем запускаемого образа гостевой системы.
Если каталог уже существует, будет создан новый с постфиксом *_х*, где x - это число от 1 до максимально возможного.

Скрипт попробует обратиться к утилите *natch-qemu-img*, входящей в поставку *Natch*, чтобы проверить ее доступность, так как она будет нужна при записи сценариев.

- *Количество оперативной памяти* \
Необходимо указать объем оперативной памяти, выделяемый виртуальной машине. Указывается число в гигабайтах или мегабайтах с соответствующим постфиксом G или M, например 512M.

- *Режим работы эмулятора* \
Эмулятор может быть запущен в графическом (обычном) или текстовом режиме. По умолчанию режим графический, если же необходимо работать в тестовом режиме следует дать ответ *n* или *N*. В этом случае потребуется дополнительная настройка вашего образа (в тестовом все настроено).

- *Сетевые опции* \
В этом меню пользователь может указать порты, которые необходимо пробросить в виртуальную машину. Запрос на ввод портов появится при выборе ответа *Y/y* или при нажатии клавиши *Enter*. Кроме того, будет предложено помечать не только Destination ports, но и Source. Если это необходимо, следует выбрать ответ *Y/y* или нажать клавишу *Enter*. Порты следует указывать через запятую. На каждый указанный порт будет назначен порт для обращения к машине извне, формироваться они будут следующим образом: первый порт из динамического диапазона для первого пользовательского порта, для остальных путем прибавления единицы. Например, пользователь ввел порты 7777, 8888, получим 49152 и 49153 соответственно.

- *Создание конфигурационного файла для модулей* \
Если модули есть в наличии, то следует нажать *Enter*, *y* или *Y*, в противном случае ввести *n* или *N*. Если конфигурационный файл нужен, будет предложено ввести путь к папке, содержащей модули. 

- *Получение символьной информации* \
Далее пользователю предложат скачать отладочные символы для системных библиотек, от которых зависит его приложение, и символы ядра операционной системы.
Если отладочные символы нужны (а чаще всего так и есть) то следует нажать *Enter*, *y* или *Y*, в противном случае ввести *n* или *N*. В случае если на предыдущем
шаге модули не были выбраны, то при согласии на получение отладочной информации, она будет скачана для модулей ядра.

- *Генерация конфигурационного файла для ядерных сущностей* \
Следующий вопрос коснется конфигурационного файла *task.cfg*. Если вы впервые создаете конфигурацию для образа, следует воспользоваться ответом по умолчанию (*Enter*, *y*, *Y*).
Если же вы уже работали с этим образом и получали конфигурационный файл с этого этапа -- вопрос можно пропустить, но не забудьте скопировать *task.cfg* в рабочую директорию нового проекта. Если не уверены, что файл от нужного образа -- лучше ответить да.

Вопросы закончились, теперь скрипт попросит ввести пароль администратора. Далее будет происходить монтирование образа, удостоверьтесь,
что в системе не работают другие виртуальные машины. После чего все действия будут происходить автоматически и могут занять продолжительное время.

Автоматически будут происходить следующие действия:

- *Получение отладочных символов* \
Этап может быть опущен, если пользователь отказался от скачивания отладочной информации. Если нет, то на этом этапе будет произведено сканирование образа, получение
файлов из него, а так же скачивание отладочных символов разными методами (если один способом не получилось, будет использован другой). Так же будут найдены и скачаны
символы для интерпретаторов Python, символы для Java.

- *Генерация task.cfg* \
Сразу после скачивания модулей будет запущен эмулятор с целью получить информацию о смещениях структур ядра, если конечно была указана необходимость генерации.
В штатной ситуации эмуолятор сам завершит работу и наступит следующий этап.

- *Извлечение символьной информацмм* \
Это последний этап настройки проекта. Будут просканированы все модули и пострена база отладочных символов.

На этом настройка окончена.

Кроме командных строк будет сгенерирована заготовка конфигурационного файла *Natch*. В полученном файле описаны все возможные секции и поля с примерами заполнения,
часть из которых закомментирована. При необходимости этот файл можно отредактировать -- раскомментировать нужные секции и внести актуальные значения параметров.
Имя конфигурационного файла задается по умолчанию, а именно *natch.cfg*.

Полученные скрипты *run_record.sh* и *run_replay.h* применяются для работы с *Natch* для записи сценария работы виртуальной машины и воспроизведения соответственно.

С версии *Natch 2.3* предусмотрена работа с несколькими сценариями в рамках одного проекта, в связи с чем в скрипты записи и воспроизведения добавился некоторый интерактив.

При запуске скрипта *run_record.sh* будет запрошено имя сценария. В случае пропуска поля ввода, имя будет назначено автоматически (*record*).
Обратите внимание, что при указании одинаковых имен сценарии будут перезаписаны. Сценарии располагаются в отдельных папках с указанными пользователем названиями.
В каждую такую папку помещаются все необходимые для работы сценария файлы - журнал, оверлей, конфигурационный файл для помеченных данных, логи сетевых взаимодействий и т.д.
Именно в папке со сценарием будет находиться вторая часть основного конфигурационного файла (*taint.cfg*), который следует отредактировать перед воспроизведением.

При запуске скрипта *run_replay.sh* ситуация может разворачиваться несколькими способами:

* *У нас один сценарий и один снапшот*. В этом случае воспроизведение запустится и отработает без участия пользователя.
* *У нас один сценарий и несколько снапшотов*. Сценарий будет выбран по умолчанию, а для загрузки нужного снапшота нужно будет выбрать его из меню (с помощью стрелочек и клавиши Enter).
* *У нас несколько сценариев и один снапшот (для выбранного сценария)*. Для выбора сценария будет отображено меню с доступными сценариями, снапшот загрузится автоматически.
* *У нас несколько сценариев и несколько снапшотов (для выбранного сценария)*. В обоих случаях будет отображено меню.

Помимо этого скрипт *run_replay.sh* имеет два необязательных параметра *scenario_name* и *snapshot_name*. Например, если во время записи был создан сценарий с названием *sample* и в процессе работы был сохранен снапшот с именем *state*, то запустить воспроизведение с этого момента можно передав скрипту параметры ``./run_replay.sh sample state``. Обратите внимание, что требуется указывать оба параметра, в противном случае они будут проигнорированы, и скрипт будет вести себя как описано выше. Если во время работы снапшот не был сохранен, то следует указать имя стартового снапшота, а именно *init*.

В процессе работы скрипта *natch_run.py* вызывается ряд других скриптов, входящих в поставку *Natch*. Если на каком-то из этапов что-то пошло не так или пользователь отказался от какой-то опции а потом передумал, эти скрипты можно запускать самостоятельно. Все они оснащены опцией *-h* для получения справки о параметрах. Далее приведено краткое описание скриптов:

- *module_config.py* - генерирует конфигурационный файл *module.cfg*
- *debug_info.py* - скачивает символьную информацию для модулей и ядра, модифицирует *module.cfg*, на вход принимает его же.
- *symbol_info.py* - парсит символьную информацию, формирует базу символов. Так же требуется *module.cfg*.

После создания проекта в текущей директории появится еще один файл. Это файл с конфигурацией проекта, речь о котором пойдет в следующем разделе.

### <a name="natch_save_settings"></a>5.2.1. Создание проекта с помощью конфигурационного файла

При создании проекта пользователь был вынужден отвечать на вопросы скрипта, однако все они были записаны и могут быть переиспользованы.
Сохранено это все в файле под названием `settings_<project_name>.ini`, файл располагается в текущей директории.

Сохраняются настройки и в случае нештатного завершения работы скрипта, например, если что-то пошло не так на этапе генерации `task.cfg`.

Конфигурационный файл `settings_test.ini` в максимальной комплектации выглядит следующим образом:

```ini
[Settings]
workdir = test
ram = 4G
text_mode = false
ports_forwarding = true
source_ports = true
ports_str = 8888,7777
module_config = true
module_dir = /home/Quick_Start_Sample/s_1
debug_info = true
tuning = true
```
Некоторые параметры могут отсутствовать, если, например, вы отказались от пробрасывания портов.

Пройдемся по параметрам:
 - `workdir` - рабочая директория проекта
 - `ram` - количество выделенной машине оперативной памяти
 - `text_mode` - режим работы эмулятора (текстовый или графический)
 - `port_forwarding` - необходимость проброса портов
 - `source_ports` - необходимость проброса source портов
 - `ports_str` - собственно проброшенные порты
 - `module_config` - необходимость включения модулей в проект
 - `module_dir` - путь к директории с модулями
 - `debug_info` - необходимость получения отладочной информации
 - `tuning` - необходимость генерации `task.cfg`

Если вы хотите создать проект, используя уже готовый конфигурационный файл, но не хотите, например, ждать генерацию `task.cfg`,
просто установите значение параметра `tuning` в `false`.

Использовать конфигурационный файл с настройками проекта можно следующим образом:
```
natch_run.py <path_to_image> -c settings_test.ini
```

Единственное что попросит у вас скрипт - пароль администратора. Остальная работа будет проделана автоматически.

### <a name="natch_append_modules"></a>5.2.2. Пополнение конфигурационного файла module.cfg

При работе с инструментом может возникнуть желание дополнить список модулей, указанных при настройке проекта. 
Для этого можно использовать скрипт `append_module_config.py`, расположенный в папке `utils` (полный путь: `/usr/bin/natch/bin/natch_scripts/utils`).

```bash
append_module_config.py [-h] [-d WORKDIR] -D MODULEDIR -i IMAGE
```
Скрипт потребует два обязательных параметра: путь к директории с новыми модулями (`-D`), а так же образ, используемый в проекте (`-i`), для скачивания информации о зависимых библиотечных модулях.
Если скрипт запускается не из рабочей директории проекта, необходимо указать путь к ней, используя опциональный параметр `-d`.

В процессе работы скрипта будет проанализирован каталог с новыми модулями, исследованы зависимости и скачана информация о библиотечных модулях (если есть), а так же перестроена символьная информация.
Если на этапе конфигурирования проекта не была скачана отладочная информация для ядра и интерпретаторов, то здесь есть возможность это исправить (будет задан соответствующий вопрос).

Для работы потребуется пароль администратора для монтирования образа. На выходе получим новый `module.cfg` и обновленные каталоги с информацией о модулях.

### <a name="natch_change_settings"></a>5.2.3. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны следующие параметры: размер оперативной памяти, проброшенные порты, режим работы эмулятора.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS] [-t TEXT_MODE]
```
Все параметры являются опциональными. Параметр, отвечающий за режим работы *Natch*, не может быть использован в группе с другими параметрами, при их совместном использовании остальные параметры будут проигнорированы.

- `-d`
  Директория. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- `-m`
  Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- `-p`
  Проброшенные порты. Указать список новых портов для проброса через запятую без пробелов. Прошлый список будет заменен. Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и конфигурационные файлы инструмента (при желании).
- `-t`
  Режим работы эмулятора. Предполагается два режима - графический и текстовый. Чтобы переключиться в текстовый режим следует использовать аргумент *yes*, в противном случае - *no*.

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343 -t no
```
Такой запуск приведет к изменению скриптов запуска (`run_qemu.sh`, `run_record.sh`, `run_replay.sh`), а так же будет предложено выбрать в каких сценариях следует внести изменения и в конфигурационные файлы. Если такие изменения не требуются - нужно нажать клавишу *ESC*.


## 5.3. Определение источников пометки
### 5.3.1. Пометка файлов

*Natch* может помечать отдельные файлы в гостевой системе и отслеживать модули и функции, которые были затронуты в результате работы с ними. При этом берутся в расчет только операции чтения.

Исполняемые файлы помечаться таким способом не будут, так как они не открываются для чтения пользовательским кодом, а отображаются
прямо в адресное пространство ядерными функциями.
Аналогично не будет детектироваться работа драйвера жесткого диска с местом хранения заданного файла.

Задать необходимые для пометки файлы можно в [конфигурационном файле для помеченных данных](4_configs.md#taint_config).


### 5.3.2. Пометка входящих сетевых пакетов

*Natch* способен помечать весь сетевой трафик, который приходит в виртуальную машину извне.
Пометка полностью локального трафика на данный момент осуществляется через пометку сокетов в секции *[TaintFile]* (подробнее в описании секции *TaintFile* [конфигурационного файла](4_configs.md#taint_config)).

Для управления пометкой пакетов используется секция *[Ports]* конфигурационного файла (подробнее в пункте [Конфигурационный файл для помеченных данных](4_configs.md#taint_config) секция *Ports*).

Пакеты помечаются целиком, вместе с заголовком второго уровня.
Для пометки можно фильтровать пакеты по протоколу 3 уровня или по выбранным портам,
если используются протоколы TCP или UDP. Список портов можно посмотреть в [википедии](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).

Возможны следующие варианты работы:

* Помечать все входные пакеты. ip_protocol=-1 + (dst=-1 или src=-1)
* Помечать все UDP-пакеты. ip_protocol=17 + (dst=-1 или src=-1)
* Помечать все TCP-пакеты. ip_protocol=6 + (dst=-1 или src=-1)
* Помечать все HTTP-пакеты от внешнего веб-сервера. ip_protocol=6 + src=80
* Помечать все SNMP-пакеты к внутреннему серверу. ip_protocol=17 + dst=161
* Помечать все ICMP-пакеты. ip_protocol=1
* Помечать другие IP-пакеты, относящиеся к выбранному протоколу 3 уровня. ip_protocol=*x*, где *x* можно взять из [таблицы](https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers)

### 5.3.3. Пометка USB трафика

В *Natch* есть возможно помечать пакеты от USB устройств.

Для проброса USB устройств в виртуальную машину потребуется сделать ряд действий:

* В хостовой системе создать файл /lib/udev/rules.d/90-udev.rules с содержимым:

```bash
SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", MODE="0666"
```
* Выполнить команды:

```bash
sudo udevadm control --reload
sudo udevadm trigger
```

Так же помимо обычной настройки конфигурационных файлов, в этом случае требуется внести изменения
в скрипты запуска инструмента. На данный момент, это необходимо делать вручную.

Для работы с USB устройством в скрипты `run_record.sh` и `run_replay.sh` в конфигурацию запуска виртуальной машины необходимо добавить строку:
```
-usb -device usb-ehci,id=ehci -device usb-host,hostbus=X,hostaddr=Y,bus=ehci.0
```
Где вместо `X` и `Y` у параметров `hostbus` и `hostaddr` соответственно нужно указать параметры реального USB устройства, которое будет проброшено в
виртуальную машину.

Узнать эти параметры можно с помощью команды `lsusb`.

Пример вывода команды:
```
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 059: ID 05ac:12a8 Apple, Inc. iPhone5/5C/5S/6
Bus 001 Device 056: ID 0951:1665 Kingston Technology Digital DataTraveler SE9 64GB
Bus 001 Device 055: ID 05e3:0608 Genesys Logic, Inc. Hub
```

В этом выводе параметр `Bus` это `hostbus`, а `Device` -- `hostaddr`.

Если мы хотим пробросить флешку Kingston из представленного вывода, то командная строка будет выглядеть следующим образом:
```
-usb -device usb-ehci,id=ehci -device usb-host,hostbus=1,hostaddr=56,bus=ehci.0
```

Строка будет одинаковой как для режима записи, так и для воспроизведения, однако, в режиме воспроизведения устройство не будет подключено, поэтому
при переподключении устройства или его отсутствия нет необходимости править параметры.

После того как сценарий был записан, необходимо внести измнения в конфигурационный файл сценария. Если проект был собран на версии *Natch 3.0*,
то в `taint.cfg` необходимо раскомментировать секцию `USB`:
```
[USB]
on=true
```
Если используется проект с более ранних версий, эту секцию необходимо дописать в конфигурационный файл.


### <a name="automation"></a>5.4. Автоматизированное выполнение

После обновления Natch ранее записанные сценарии могут не работать. Перезапись тестовых сценариев может быть достаточно трудоёмка. Здесь на помощь приходит автоматизация. Также она будет полезна при необходимости встраивания Natch в CI/CD.
Средствами bash и expect возможно автоматизировать создание проекта, запись сценария и его последующее воспроизведение, а также создание проекта в Snatch и проверку его содержания. Затем при помощи Selenium Snatch запускается в браузере и генерируется PDF отчет.

Автоматизация записи сценария возможна при использовании консольных действий на Linux (через telnet) или Windows 10-11 (при использовании ssh).

**Важно!** Перед использованием автоматизации убедитесь в том, что

* Natch установлен и установка зависимостей была выполнена.
* Snatch, соответствующей установленной версии Natch, установлен, и snatch_setup.sh уже выполнялся ранее.

#### Реализация автоматизации

В архиве с тестовым примером (см. раздел [Получение образа и тестовых примеров](3_quickstart.md#test_sample)) находится скрипт automation.sh, скрипты автозаписи сценариев для тестовых примеров (run_record_sample1.exp и run_record_sample2.exp), а также python-скрипт snatch.py. Необходимо сохранить все файлы в одном каталоге, и запустить скрипт automation.sh. Он выполняет следующие действия:

* Устанавливает требующиеся пакеты (expect, selenium и др.).
* Удаляет последний проект, созданный при автоматизированном выполнении.
* Создает новый проект в подкаталоге `autotest`. Создание нового проекта описано в разделе [Автоматизированная настройка](3_quickstart.md#autoconfig).

Далее, для каждого из двух примеров
* Записывает тестовый сценарий, используя скрипт run_record_sampleX.exp. Запись сценария вручную [описана в разделе Запись сценария работы](3_quickstart.md#record_scenario)
* Выполняет воспроизведение записанного сценария с целью получения объекта анализа. Воспроизведение сценария детально описано в разделе [Воспроизведение сценария и сбор данных для анализа](3_quickstart.md#replay_scenario).

После выполнения в подкаталоге `autotest` появляются архивы autotest+sample1.tar.zst и autotest+sample2.tar.zst для дальнейшего анализа.

Затем
* Выполняется запуск предварительно установленного Snatch.
* Средствами Snatch CI API (см. раздел [CI/CD](6_snatch.md#66-cicd)) сгенерированные архивы загружаются в базу данных Snatch (создаются проекты).
В случае ошибки блокировки базы данных Snatch (возможно при высокой нагрузке), попытки создания продолжаются до тех пор, пока не происходит ее разблокировка.
* После загрузки проверяется содержание проектов (Call Graph, Interpreter Call Graph, Resources, Process Tree, Files, Process Info, Process Timeline), и выводится статистика, содержащая размер в байтах каждого из полученного вывода JSON.
* Snatch открывается в браузере (Firefox), где поочередно открывается каждый проект, выполняется переход на Module Graph для активации этого графа в отчете, а затем генерируется сам PDF отчет, который в конце сохраняется в каталоге ~/Downloads. Этими действиями управляет snatch.py на основе Selenium. 

#### Адаптация скриптов автоматизации

Скрипты автоматизации содержат комментарии, которые помогут вам адаптировать их под свои проекты. Для этого требуются следующие действия:

##### automation.sh:

* В функции `checkRequirements` отредактируйте параметры `requirements` и `pip_requirements`, указав через пробел пакеты, которые требуется проверить/ установить на хост.
* В функции `recAndReplay` измените параметр `samples`, указав через пробел названия тестовых сценариев.
* Эти названия тестовых сценариев соответствуют названиям в именах скриптов `run_record_<scenarioname>.exp`, которые также должны быть созданы.
* В функции `genTaintCfg` отредактируйте генерируемый `taint.cfg` файл (см. раздел [Конфигурационный файл для помеченных данных](4_configs.md#taint_config)), в котором указываются помечаемые файлы, сокеты, протоколы, порты и т.д.

Также необходимо иметь в виду следующее:

* Скрипт ищет qcow2 образ в каталоге со скриптом. Убедитесь в том, что в каталоге только один qcow2 файл или отредактируйте параметр `qcow2Path`.
* Имя проекта `autotest` можно изменить в параметре `projName`

##### run_record_<scenarioname>.exp
* Отредактируйте код, начиная с `# OS login`, причем код до `# Connect from host to the VM by telnet to save a snapshot` является подготовительным и не попадет в записываемый сценарий. Записываемый сценарий, который вы планируете в дальнейшем анализировать, должен начинаться с `# When snapshot is saved, everything is ready to record a scenario`. Используйте любое руководство по expect для получения подробной информации о реализации.
* Для пробрасывания порта из хоста в образ используйте `hostfwd` параметр у `-netdev` строки запуска natch (см. пример в run_record_sample2.exp).
* Когда сценарий записан, и ваш скрипт функционирует корректно, вы можете отключить вывод из виртуальной машины. Для этого нужно раскомментировать строку `#log_user 0`

#### Пример автоматической проверки

Выполните скрипт automation.sh. При этом появляется описание действий, выполняемых скриптом. Также определяется образ qcow2, который расположен в каталоге со скриптом:
```
ISP RAS Natch - Automation Sample.

The script automatically performs the following:
1. Installs the required packages.
2. Cleans up the previous autotest project.
3. Creates a new project (natch_run.py).
4. For both existing samples:
 ∟ Records a test scenario (run_record_*.exp).
 ∟ Replays it (run_replay.sh).
5. The generated archives are added to Snatch DB using Snatch CI API.
6. The content of the projects is tested by the available options of Snatch CI API.
7. The PDF reports for the projects are generated by Snatch via browser.
The PDF reports are saved to ~/Downloads

Image name: test_image_debian
QCOW2 image: /vms/test_image/test_image_debian.qcow2
Project dir: /vms/test_image/autotest

The script must know the Snatch directory which contains snatch_*.sh.
Warning! Installation (snatch_setup.sh) must be executed before running the further actions.
Enter path to Snatch directory: /
```

На данном этапе требуется ввести полный путь к директории Snatch. 
По нажатии Enter появляется запрос sudo. После ввода пароля следует установка требующихся компонент.
Затем появляется запрос sudo для создания проекта, после чего запускается создание проекта в natch_run.py:

```
spawn /usr/bin/natch/bin/natch_scripts/natch_run.py /vms/test_image/test_image_debian.qcow2

Image: /vms/test_image/test_image_debian.qcow2
OS: Linux

Attention! To successfully create a project you will need a root password

Enter path to directory for project (optional): autotest
Directory for project files /vms/test_image/autotest was created

Checking natch-qemu-img utility...
Utility natch-qemu-img is ok

Common options
Enter RAM size with suffix G or M (e.g. 4G or 256M): 4G
Do you want to run emulator in graphic mode? [Y/n] Y

Network option
Do you want to use ports forwarding? [Y/n] N

Modules part
Do you want to create module config? [Y/n] Y
Enter path to binaries dir: .

Debug info part
Do you want to get debug info for system modules? [Y/n] Y

Generate config file task.cfg? (recommended) [Y/n] Y

Waiting for module config generating
Module config is completed

Your config file module.cfg for modules was created
ELF files found: 4
Map files found: 0

The steps above require a root password

[sudo] password for gteys: 
Mounting img - OK                                                                                             
Files copied from the guest system: 2                                                                         
Umounting img - OK                                                                                            
Mounting img - OK                                                                                             

...

Settings completed! Now you can launch emulator and enjoy! :)

	Natch in record mode: 'run_record.sh'
	Natch in replay mode: 'run_replay.sh'
	Qemu without Natch: 'run_qemu.sh'
```

По завершении работы natch_run.py для виртуальной машины создается diff файл:
```
Formatting '/vms/test_image/autotest/sample1/test_image_debian.diff', fmt=qcow2 cluster_size=65536 extended_l2=off compression_type=zlib size=21474836480 backing_file=/vms/test_image/test_image_debian.qcow2 backing_fmt=qcow2 lazy_refcounts=off refcount_bits=16
```

Следом появляется сообщение ```Recording a sample1 scenario...```. На этом этапе запускается скрипт run_record_sample1.exp. Этот скрипт загружает виртуальную машину и автоматически записывается тестовый сценарий для первого примера. 


По завершении работы expect-скрипта активность возвращается к automation.sh и возникает сообщение ```Replaying the sample1 scenario...```, а затем 
```
Natch monitor - type 'help' for more information
(natch) 
Natch_v.2.4_work-8103-g2ae3f27bbb
(c) 2020-2023 ISP RAS

Reading Natch config file...
Natch is working in NORMAL mode

Network logging enabled
Task graph enabled
Module graph enabled
Taint enabled
Config is loaded.
File monitor storage /vms/test_image/autotest/output_sample1/filemon.log created successfully
Module binary log file /vms/test_image/autotest/output_sample1/log_m_b.log created successfully
Modules: started reading binaries
Modules: finished with 82 of 82 binaries for analysis
thread_monitor: identification method is set to a complex developed at isp approach
Started thread monitoring
Tasks: config file is open.
Network json log file: "/vms/test_image/autotest/output_sample1/tnetwork.json"
Taint log storage file /vms/test_image/autotest/output_sample1/taint.log created successfully
Binary call_stack log file /vms/test_image/autotest/output_sample1/log_cs_b.log created successfully
Tainting file: curl.txt 
Detected module /vms/test_image/autotest/libs/54ce98cf6f65914636ace17148725666/vmlinux-5.10.0-17-amd64 execution
Detected module /vms/test_image/autotest/libs/9b8f02224b6497f2fd72ebf18d1949a3/libc-2.31.so execution
Detected module /vms/test_image/Sample1_bins/test_sample execution
Detected module /vms/test_image/Sample1_bins/test_sample_2 execution
File /home/user/Sample1/curl.txt is opened, handle = 0x0000000000000003
File /home/user/Sample1/curl.txt is opened, handle = 0x0000000000000001
Detected module /vms/test_image/autotest/libs/2e93e13b373621a7d3aaddacd6701fa8/libssl.so.1.1 execution
Detected module /vms/test_image/autotest/libs/6841efca9a812a58ac478ca5f8233952/libpthread-2.31.so execution
Detected module /vms/test_image/autotest/libs/cb5e1aed69e5825344104409380618b7/libffi.so.7.1.0 execution
Detected module /vms/test_image/autotest/libs/37c74ba908b7557fdc1301b97e4599e2/libkeyutils.so.1.9 execution
Detected module /vms/test_image/autotest/libs/5ca6b88c0086c158c365ccdaee252ea7/libdl-2.31.so execution
Detected module /vms/test_image/autotest/libs/c321937f4b7676d21947a671f6512a9f/libresolv-2.31.so execution
Detected module /vms/test_image/autotest/libs/d861ebb9591e1df1a976daed3647b3da/libkrb5support.so.0.1 execution
Detected module /vms/test_image/autotest/libs/66c3bc8b77614fd5412317f9b504eca0/libcom_err.so.2.1 execution
Detected module /vms/test_image/autotest/libs/fe8eadb6d18a039846578f3c06ff4de7/libk5crypto.so.3.1 execution
Detected module /vms/test_image/autotest/libs/b39a79b8f3c07df3c91e50a2fb8ed970/libkrb5.so.3.3 execution
Detected module /vms/test_image/autotest/libs/4f9f1f95098b2baaba560f5e1ff6f9a3/libgssapi_krb5.so.2.2 execution
Detected module /vms/test_image/autotest/libs/83c9488ccb57383a628a199f9e7b17cb/libcrypto.so.1.1 execution
Detected module /vms/test_image/autotest/libs/8e12a00fd2769b5130e11cf3a773289f/libz.so.1.2.11 execution
Detected module /vms/test_image/autotest/libs/855da59f8deb05d1edb1391aa41a5545/libdb-5.3.so execution
File /home/user/Sample1/curl.txt is opened, handle = 0x0000000000000001

============ Statistics ============

Tainted files             : 1
Tainted packets           : 20
Tainted processes         : 3
Tainted modules           : 3
Tainted file reads        : 0
Tainted memory accesses   : 33166


Compressing data. Please wait..

autotest+sample1.tar.zst completed
``` 

Далее последние шаги, начиная с создания diff файла, повторяются снова для второго примера. По завершении процедуры для обоих примеров появляется сообщение:

```
These are the archives we will test in Snatch:
/vms/test_image/autotest/autotest+sample1.tar.zst
/vms/test_image/autotest/autotest+sample2.tar.zst
```


Затем запускается Snatch, сгенерированные архивы добавляются в него и проходят проверку:

```
Snatch started.
Creating a project sample1
The project sample1 has been created.
Checking content...
   ∟ callgraph size: 194862 bytes
   ∟ interp_callgraph size: 0 bytes
   ∟ resources size: 4643 bytes
   ∟ process_tree size: 2729 bytes
   ∟ files size: 6752 bytes
   ∟ process_info size: 6902 bytes
   ∟ process_timeline size: 8942 bytes
The content check for the project sample1 has been finished.
Creating a project sample2
The project sample2 has been created.
Checking content...
   ∟ callgraph size: 194434 bytes
   ∟ interp_callgraph size: 0 bytes
   ∟ resources size: 3546 bytes
   ∟ process_tree size: 1298 bytes
   ∟ files size: 2485 bytes
   ∟ process_info size: 3099 bytes
   ∟ process_timeline size: 4071 bytes
The content check for the project sample2 has been finished.
```

После чего запускается snatch.py. Он открывает Firefox. Открывается проект, выполняется переход на Module Graph для его активации, а затем генерируется и сохраняется PDF отчет. 
Действия повторяются для второго проекта.

```
[WDM] - Downloading: 19.9kB [00:00, 11.2MB/s]                                                                 
[WDM] - Downloading: 100%|███████████████████████████████████████████████| 3.10M/3.10M [00:00<00:00, 7.11MB/s]
Snatch opened in browser.
Report /home/gteys/Downloads/report-sample1-24-1-2024.pdf (342.62 KB) has been generated.
Report /home/gteys/Downloads/report-sample2-24-1-2024.pdf (414.53 KB) has been generated.
```

В результате в каталоге Downloads мы получили PDF отчеты для двух тестовых приложений.

Следует обратить особое внимание, что автоматизация намеренно не очищает базу данных уже загруженных ранее проектов в Snatch, так что, если вы ранее уже загружали свои проекты в него, они не пропадут; более того, - для них также будут сгенерированы отчеты.

