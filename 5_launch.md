<div style="page-break-before:always;">
</div>

# <a name="natch_run_main"></a>5. Запуск Natch

Для работы *Natch* потребуется установка ряда зависимостей. Сделать это можно с помощью скрипта *setup_requirements.sh*, который находится в папке *natch_scripts* (*Natch* устанавливается в директорию `/usr/bin/natch/bin/`). В результате работы будут установлены python пакеты и deb пакет, необходимые для работы скриптов, входящих в поставку инструмента. В процессе работы потребуется пароль администратора.

Предварительно следует скачать и установить *Natch* (подробнее в разделе [Комплект поставки Natch](1_quickstart.md#complect)).

## <a name="natch_run_script"></a>5.1. Использование скрипта для генерации командных строк запуска

В поставку инструмента входит скрипт *natch_run.py*, который нужен для генерации командных строк для запуска *Natch*, а так же для первоначальной настройки инструмента. Скрипт *natch_run.py* расположен в директории *natch_scripts*. Запускать скрипт можно из любого расположения, готовые скрипты для запуска инструмента и все конфигурационные файлы будут помещены в рабочей директории, указанной пользователем или назначенной автоматически.

В процессе выполнения скрипта пользователь должен уточнять параметры запуска инструмента. На выходе сформируются три скрипта: *run_record.sh* и *run_replay.sh* для запуска *Natch* в режиме записи и
воспроизведения работы соответственно, а так же *run_qemu.sh* для запуска Qemu без *Natch*.

Скрипт *natch_run.py* имеет три параметра, один обязательный и два опциональных. Обязательный параметр это путь к образу системы, опциональные - путь к ядру (опция kernel эмулятора Qemu, если ядро ОС не загружается из образа системы) и название операционной системы, для которой будет использован инструмент (по умолчанию Linux, предоставляется выбор из следующих вариантов: Linux, FreeBSD, Win7). Так же скрипт можно запустить с опцией *-h* и получить справку по доступным опциям.

Описание команды и ее параметров представлено ниже:
```text
natch_run.py image [-h] [-k KERNEL] [-o {Linux, FreeBSD, Win7}]
```
Пример запуска скрипта:
```bash
./natch_run.py <image> -o Linux
```

Список вопросов, которые будут заданы при выполнении скрипта:

- *Путь к директории проекта* \
Необходимо указать полный путь или только название папки, которая будет создана для хранения всех скриптов, конфигураций и прочих файлов инструмента.
Внутри этой директории будет создана еще одна папка с именем *output*, в которую будут помещены выходные файлы работы инструмента.
Параметр является опциональным, в случае пропуска рабочий каталог будет называться именем запускаемого образа гостевой системы.
Если каталог уже существует, будет создан новый с постфиксом *_х*, где x - это число от 1 до максимально возможного.

- *Количество оперативной памяти* \
Необходимо указать объем оперативной памяти, выделяемый виртуальной машине. Указывается число в гигабайтах или мегабайтах с соответствующим постфиксом G или M, например 512M.

- *Режим работы эмулятора* \
Эмулятор может быть запущен в графическом (обычном) или текстовом режиме. По умолчанию режим графический, если же необходимо работать в тестовом режиме следует дать ответ *n* или *N*. В этом случае потребуется дополнительная настройка вашего образа (в тестовом все настроено).

После этих вопросов скрипт попробует обратиться к утилите *natch-qemu-img*, входящей в поставку *Natch*, чтобы проверить ее доступность, так как она будет нужна при записи сценариев.

- *Сетевые опции* \
В этом меню пользователь может указать порты, которые необходимо пробросить в виртуальную машину. Запрос на ввод портов появится при выборе ответа *Y/y* или при нажатии клавиши *Enter*. Кроме того, будет предложено помечать не только Destination ports, но и Source. Если это необходимо, следует выбрать ответ *Y/y* или нажать клавишу *Enter*. Порты следует указывать через запятую. Указываемые порты должны лежать в диапазоне [1 .. 9999]. Порт для обращения к машине извне будет формироваться по принципу: *user_port + 10000*.

- *Создание конфигурационного файла для модулей* \
Если модули есть в наличии, то следует нажать *Enter*, *y* или *Y*, в противном случае ввести *n* или *N*. Если конфигурационный файл нужен, будет предложено ввести путь к папке, содержащей модули. Так как генерация конфигурационного файла может занять продолжительное время, этот процесс будет запущен параллельно. По окончании настроек будет предложено или ознакомиться с логом процесса генерации или подождать завершения процесса, а уже затем ознакомиться с логом (если сообщения о просмотре лога не будет, значит он пустой и все прошло великолепно).

- *Генерация конфигурационного файла для ядерных сущностей* \
Следующий вопрос коснется конфигурационного файла *task.cfg*. Если вы впервые создаете конфигурацию для образа, следует воспользоваться ответом по умолчанию (да). На этом этапе будет запущен эмулятор для извлечения информации о структурах ядра. Если же вы уже работали с этим образом и получали конфигурационный файл с этого этапа - вопрос можно пропустить, но не забудьте скопировать *task.cfg* в рабочую директорию нового проекта. Если не уверены, что файл от нужного образа - лучше ответить да и дождаться генерации файла.

Если конфигурационный файл для модулей не успел построиться к этому моменту, будет выведено сообщение `Waiting for module config generating`. Следует дождаться окончания работы скрипта. Если в процессе генерации файла происходили какие-то нештатные события, будет предложено ознакомиться с логом.

- *Символьная информация* \
Далее пользователю предложат скачать отладочные символы для системных библиотек, от которых зависит его приложение, и символы ядра операционной системы. Для выполнения этой операции потребуется пароль для sudo. В случае нештатных ситуаций пользователь получит соответствующие сообщения, а произвести скачивание символов можно будет отдельно, воспользовавшись скриптом ``debug_info.py`` (подробнее в пункте [Автоматическая загрузка отладочной информации для разделяемых библиотек](4_configs.md#debug_info)). Если не было выбрано создание конфигурационного файла для модулей, то на этом этапе будут скачаны только модули ядра.

Затем произойдет извлечение символьной информации для скачанных модулей.

На этом настройка окончена.

Кроме командных строк будет сгенерирована заготовка конфигурационного файла *Natch*. В полученном файле описаны все возможные секции и поля с примерами заполнения, часть из которых закомментирована. При необходимости этот файл можно отредактировать -
раскомментировать нужные секции и внести актуальные значения параметров. Имя конфигурационного файла задается по умолчанию, а именно *natch.cfg*.

Полученные скрипты *run_record.sh* и *run_replay.h* применяются для работы с *Natch* для записи сценария работы виртуальной машины и воспроизведения соответственно.

С версии *Natch 2.3* предусмотрена работа с несколькими сценариями в рамках одного проекта, в связи с чем в скрипты записи и воспроизведения добавился некоторый интерактив.

При запуске скрипта *run_record.sh* будет запрошено имя сценария. В случае пропуска поля ввода, имя будет назначено автоматически (*record*). Обратите внимание, что при указании одинаковых имен сценарии будут перезаписаны.
Сценарии располагаются в отдельных папках с указанными пользователем названиями. В каждую такую папку помещаются все необходимые для работы сценария файлы - журнал, оверлей, конфигурационный файл для помеченных данных, логи сетевых взаимодействий и т.д.
Именно в папке со сценарием будет находиться вторая часть основного конфигурационного файла (*taint.cfg*), который следует отредактировать перед воспроизведением.

При запуске скрипта *run_replay.sh* ситуация может разворачиваться несколькими способами:

* *у нас один сценарий и один снапшот*. В этом случае воспроизведение запустится и отработает без участия пользователя.
* *у нас один сценарий и несколько снапшотов*. Сценарий будет выбран по умолчанию, а для загрузки нужного снапшота нужно будет выбрать его из меню (с помощью стрелочек и клавиши Enter).
* *у нас несколько сценариев и один снапшот (для выбранного сценария)*. Для выбора сценария будет отображено меню с доступными сценариями, снапшот загрузится автоматически.
* *у нас несколько сценариев и несколько снапшотов (для выбранного сценария)*. В обоих случаях будет отображено меню.

Помимо этого скрипт *run_replay.sh* имеет два необязательных параметра *scenario_name* и *snapshot_name*. Например, если во время записи был создан сценарий с названием *sample* и в процессе работы был сохранен снапшот с именем *state*, то запустить воспроизведение с этого момента можно передав скрипту параметры ``./run_replay.sh sample state``. Обратите внимание, что требуется указывать оба параметра, в противном случае они будут проигнорированы, и скрипт будет вести себя как описано выше. Если во время работы снапшот не был сохранен, то следует указать имя стартового снапшота, а именно *init*.

В процессе работы скрипта *natch_run.py* вызывается ряд других скриптов, входящих в поставку *Natch*. Если на каком-то из этапов что-то пошло не так или пользователь отказался от какой-то опции а потом передумал, эти скрипты можно запускать самостоятельно. Все они оснащены опцией *-h* для получения справки о параметрах. Далее приведено краткое описание скриптов:

- *module_config.py* - генерирует конфигурационный файл *module.cfg*
- *debug_info.py* - скачивает символьную информацию для модулей и ядра, модифицирует *module.cfg*, на вход принимает его же.
- *symbol_info.py* - парсит символьную информацию, формирует базу символов. Так же требуется *module.cfg*.


### 5.1.1. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны следующие параметры: размер оперативной памяти, проброшенные порты и режим работы эмулятора.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS] [-t TEXT_MODE]
```
Все параметры являются опциональными.

- Директория. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- Проброшенные порты. Указать список новых портов для проброса через запятую без пробелов. Прошлый список будет заменен. Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и конфигурационные файлы инструмента (при желании).
- Режим работы эмулятора. Предполагается два режима - графический и текстовый. Чтобы переключиться в текстовый режим следует использовать аргумент *yes*, в противном случае - *no*.

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343 -t no
```
Такой запуск приведет к изменению скриптов запуска (`run_qemu.sh`, `run_record.sh`, `run_replay.sh`), а так же будет предложено выбрать в каких сценариях следует внести изменения и в конфигурационные файлы. Если такие изменения не требуются - нужно нажать клавишу *ESC*.

## 5.2. Определение источников пометки
### 5.2.1. Пометка файлов

*Natch* может помечать отдельные файлы в гостевой системе и отслеживать модули и функции, которые были затронуты в результате работы с ними. При этом берутся в расчет только операции чтения.

Исполняемые файлы помечаться таким способом не будут, так как они не открываются для чтения пользовательским кодом, а отображаются
прямо в адресное пространство ядерными функциями.
Аналогично не будет детектироваться работа драйвера жесткого диска с местом хранения заданного файла.

Задать необходимые для пометки файлы можно в [конфигурационном файле для помеченных данных](4_configs.md#taint_config).


### 5.2.2. Пометка входящих сетевых пакетов

*Natch* способен помечать весь сетевой трафик, который приходит в виртуальную машину извне.
Пометка полностью локального трафика на данный момент осуществляется через пометку сокетов в секции *[TaintFile]* (подробнее в описании секции TaintFile [конфигурационного файла](4_configs.md#taint_config)).

Для управления пометкой пакетов используется секция *[Ports]* конфигурационного файла (подробнее в пункте [Конфигурационный файл для помеченных данных](4_configs.md#taint_config) секция **Ports**).

Пакеты помечаются целиком, вместе с заголовком второго уровня.
Для пометки можно фильтровать пакеты по протоколу 3 уровня или по выбранным портам,
если используются протоколы TCP или UDP. Список портов можно посмотреть в [википедии](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).

Возможны следующие варианты работы:

* Помечать все входные пакеты. ip_protocol=-1 + (dst=-1 или src=-1)
* Помечать все UDP-пакеты. ip_protocol=17 + (dst=-1 или src=-1)
* Помечать все TCP-пакеты. ip_protocol=6 + (dst=-1 или src=-1)
* Помечать все HTTP-пакеты от внешнего веб-сервера. ip_protocol=6 + src=80
* Помечать все SNMP-пакеты к внутреннему серверу. ip_protocol=17 + dst=161
* Помечать все ICMP-пакеты. ip_protocol=1
* Помечать другие IP-пакеты, относящиеся к выбранному протоколу 3 уровня. ip_protocol=*x*, где *x* можно взять из [таблицы](https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers)
