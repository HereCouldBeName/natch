<div style="page-break-before:always;">
</div>

# 3. Конфигурационные файлы Natch <a name="natch_config_main"></a>

Для работы инструмента *Natch* требуются конфигурационные файлы. Основной конфигурационный файл отдается непосредственно инструменту на вход, остальные являются источниками настроек для плагинов, входящих в состав *Natch*.

## 3.1. Основной конфигурационный файл <a name="main_config"></a>

Пример файла конфигурации приведен ниже, но пользователю может потребоваться внести в него изменения.
Содержимое файла конфигурации:

```ini
# Natch settings

# Section Version since Natch v.2.0
[Version]
version=1

# Section for path to work directory
[OutputData]
workdir=/home/user/workdir

# Section for loading task_struct offsets
[Tasks]
config=task_config.ini

# Section for loading modules
[Modules]
config=module_config.cfg
log=taint.log
params_log=params.log

[Ports]
# 6 is for tcp
ip_protocol=6
# ports are supported for tcp only yet
in=22;80;3500;5432
out=22;80;3500;5432

[Taint]
# Threshold value for tainting. Should be in decimal number system [0..255]
threshold=50
on=true

# Section for enable generating graphs
[TaintedTask]
task_graph=true
module_graph=false

# Section for tainted network packets. !Only for replay mode!
[NetTaintLog]
log=tnetpackets.log

# Section for network log in pcap. !Only for record mode!
[NetLog]
on=true
log=netpackets.log

# Section for add tainted files
[TaintFile]
list=file1.txt;file2.txt

# Section for getting coverage
[Coverage]
file=coverage.cov64
taint=true

# Section for enabling additional plugins
[Plugins]
items=bcqti,broker,addr=:5555;some_plugin

# Section for loading custom syscall config
[Syscalls]
config=custom_x86_64.cfg
```

**Секция Version**

- Поле *version*: номер версии конфигурацинного файла *Natch*. Генерируется автоматически, редактирование не требуется.

**Секция OutputData**

- Поле *workdir*: путь к директории, куда будут записываться все файлы, генерируемые инструментом.
Внутри *workdir* будут созданы два каталога *output* и *output_text*. В первый будут записаны файлы для анализа в графической подсистеме (бинарные логи, графы взаимодействия процессов и модулей, символьная информация), этот же каталог будет заархивирован. В *output_text* попадут файлы с текстовым представлением поверхности атаки (surface_functions.txt и surface_modules.txt).

**Секция Tasks**

- Поле *config*: указывается имя конфигурационного файла для распознавания процессов (подробнее в [разделе](3_configs.md#tasks_config)).

**Секция Modules**

- Поле *config*: указывается имя конфигурационного файла для распознавания модулей (подробнее в [разделе](3_configs.md#api_config)).
- Полe *log*: содержит название файла, в который в процессе работы будет записываться подробный лог помеченных данных (подробнее в [разделе](5_functional.md#taint_log)).
- Полe *params_log*: содержит название файла, в который в процессе работы будет записываться лог с помеченными параметрами функций (подробнее в [разделе](5_functional.md#taint_params_log)).

**Секция Ports**

- Поле *ip_protocol* описывает тип протокола 4 уровня. Если не указано, пакеты по этому полю не фильтруются.
- Поле *out* - фильтр по Source Port в заголовке TCP, порты перечисляются через точку с запятой.
- Поле *in* - фильтр по Destination Port в заголовке TCP, порты перечисляются через точку с запятой.

При необходимости отслеживать трафик по всем портам, в полях *in/out* секции *Ports* следует указать значение -1. Если хотя бы в одном поле будет -1, будет отслеживаться весь трафик.

**Секция Taint**

- Поле *threshold*: пороговое значение для отслеживания помеченных данных, задается десятеричным числом в диапазоне от 0 до 255. Чем больше число, тем пометка будет сильнее, то есть в поверхность атаки будут попадать минимально измененные данные.
- Поле *on*: принимает логическое значение, при установке в true отслеживание помеченных данных будет включено при старте эмулятора. Если это не требуется, следует установить значение false.

Если секция *Taint* не определена, по умолчанию отслеживание помеченных данных будет выключено и пороговое значение будет установлено в 0.

**Секция TaintedTask**

- Поле *task_graph*: принимает логическое значение, при установке в true при завершении работы эмулятора будет создан граф задач и потоков помеченных данных.
- Поле *module_graph*: принимает логическое значение, при установке в true при завершении работы эмулятора будет создан граф модулей и потоков помеченных данных.

**Секция NetTaintLog**

- Поле *log*: содержит название файла, в который в процессе воспроизведения будут записываться помеченные сетевые пакеты.

**Секция NetLog**

- Поле *on*: принимает логическое значение, при установке в true осуществляется сохранение сетевых пакетов в файл.
- Поле *log*: опциональное поле, содержит название файла для записи пакетов. Расширение указывать не нужно, оно автоматически будет *.pcap*. Если поле не задано, имя файла по умолчанию *net_packets_log.pcap*.

Использование этой секции предусмотрено только в режиме записи журнала и собирается только входящий трафик.

**Секция TaintFile**

- Поле *list*: через точку с запятой могут быть перечислены имена файлов, которые требуется пометить. Указываются имена файлов гостевой машины в формате имя + расширение. Для надежности рекомендуется не использовать пути. Пометка произойдет автоматически при запуске эмулятора.

Если включена секция *TaintFile* без указания списка файлов, плагин *taint_file* все равно будет загружен.

**Секция Coverage**

- Поле *file*: указывается имя файла, куда будет записана операция о покрытии кода.
- Поле *taint*: определяет режим сбора покрытия кода (подробнее в [разделе](5_functional.md#functional_coverage)).

**Секция Plugins**

- Поле *items*: через точку с запятой указываются плагины, не входящие в состав *Natch*, но которые должны быть загружены.

**Секция Syscalls**

- Поле *config*: указывается имя конфигурационного файла для перехвата системных вызовов (подробнее в [разделе](3_configs.md#syscalls_config)).


## 3.2. Modules <a name="api_config"></a>

В этой секции можно указать конфигурационный файл, описывающий анализируемые исполняемые модули. *Natch* может находить загруженные модули, на которые передавалось управление, но определить их имена и функции не всегда возможно.

В этом случае можно загрузить образы интересующих модулей через конфигурационный файл.
Использование этого конфигурационного файла может понадобиться в следующих случаях:

- Для правильного определения имен бинарных файлов и их экспортируемых функций
- Для подгрузки map-файла с именами функций
- Для подгрузки дополнительных ELF-файлов с отладочной информацией (подробнее в [разделе](7_appendix.md#module_config))

Из основного бинарного файла всегда читаются экспортируемые символы и отладочная информация,
сгенерированная компилятром при использовании ключа `-g`. Поддерживаются все современные компиляторы.
Также можно использовать map-файлы, сгенерированные с помощью IDA Pro. Это можно сделать через меню `File -> Produce file -> Create MAP File`.
В появившемся после ввода имени файла диалоге нужно выставлять галочку *Segmentation information*.

### 3.2.1. Автоматическая генерация конфигурационного файла

Конфигурационный файл со списком модулей может быть сгенерирован автоматически при помощи входящего в поставку скрипта *module_config.py* во время выполнения скрипта *natch_run.py* (подробнее в [разделе](4_launch.md#natch_run_script)).

Перед работой нужно установить зависимости из списка *requirements.txt* с помощью команды
```bash
pip3 install -r requirements.txt
```
Скрипт принимает ряд параметров:

- Путь к директории, содержащей модули и map-файлы (обязательный).
- Путь к рабочей директории, в которую будет помещен лог работы инструмента. По умолчанию в месте запуска скрипта.
- Флаг включения диагностических сообщений.

```bash
module_config.py folder [-h] [-l] [-d]
```
Имена map-файлов и исполняемых файлов должны соответствовать друг другу: скрипт будет искать map-файлы, приписывая суффикс .map к полному имени исполняемого файла.

Пример запуска скрипта:
```bash
./module_config.py <path_to_modules>
```
## 3.2. Tasks <a name="tasks_config"></a>

Конфигурационный файл этой секции генерируется автоматически на этапе конфигурирования *Natch*.

Если во время настроечного запуска индикатор прогресса зависает на одном пункте, то вероятно это связано с недостатком количества перехватываемых системных вызовов. Для решения проблемы можно попробовать запустить на гостевой системе какую-либо программу.

## 3.3. Syscalls <a name="syscalls_config"></a>

Конфигурационные файлы для перехвата системных вызовов поставляются с инструментом и, как правило, подгружаются автоматически.

В редких случаях следует указывать конкретный файл, но писать самостоятельно его не нужно, лучше обратиться к разработчикам.


