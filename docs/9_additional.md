<div style="page-break-before:always;">
</div>

# <a name="natch_additional"></a>9. Дополнительные возможности Natch


## <a name="natch_light"></a>9.1. Облегченный режим работы Natch

*Natch* предусматривает два режима работы: стандартный и облегченный.

В стандартном режиме происходит полный анализ с пометкой данных и построением всех логов и аналитик.
Однако, иногда пользователь может не знать что именно следует помечать. В такой ситуации может быть
полезно собрать общую картину происходящего в системе и принять решение какие ее части вызывают интерес.
В этом режиме осуществляется сбор информации о процессах, модулях, файлах, сетевых взаимодействиях.
Облегченный режим отключает анализ помеченных данных, за счет чего выполнение сценария происходит быстрее.

Переключение режимов осуществляется с помощью основного конфигурационного файла:

```ini
[Mode]
light=false|true
```

Описание секции в разделе [Основной конфигурационный файл natch.cfg](16_app_configs.md#main_config).

## <a name="taint_log"></a>9.2. Подробная трасса помеченных данных

Для более детального анализа может потребоваться больше информации, которую можно получить с помощью опции конфигурационного файла *Modules/log*.

В генерируемом логе на каждое обращение к помеченной памяти формируется расширенный набор данных.

Фрагмент лога для одного обращения:
```text
Load:
Process name: wget2 cr3:  0x1b5a5c000
Tainted access at 00007f921af88896
Access address 0x7f921a504b08 size 8 taint 0xfcfcfcfc
icount: 21216379863
Module name: /lib/x86_64-linux-gnu/libpthread.so.0 base:  0x00007f921af77000
Call stack:
    0: 00007f921af88896 in func 00007f921b3b1c40 wget2/build/lib/libwget.so.1::.recvfrom
    1: 00007f921b3c5307 wget2/libwget/net.c:861 in func 00007f921b3b0860 wget2/build/lib/libwget.so.1::.wget_tcp_read
    2: 00007f921b3bdbda wget2/libwget/http.c:990 in func 000055b58a29f350 files/wget2::.wget_http_get_response_cb
    3: 000055b58a2ac0ec wget2/src/wget.c:4017 in func 000055b58a2ac0e0 files/wget2::http_receive_response wget2/src/wget.c:4016
    4: 000055b58a2ac654 wget2/src/wget.c:2266 in func 000055b58a2ac2b0 files/wget2::downloader_thread wget2/src/wget.c:2250
    5: 00007f921af7efa1 in func 00007f921af7eeb0 /lib/x86_64-linux-gnu/libpthread.so.0
    6: 00007f921aeaf4cd
```
Не рекомендуется включать эту опцию по умолчанию, поскольку файл получается ощутимого размера
(сотни байт на каждое обращение к помеченным данным).

## <a name="taint_params_log"></a>9.3. Получение областей помеченной памяти для функций

Инструмент позволяет получить лог вызовов функций с диапазонами адресов записанных и прочитанных помеченных данных. Для получения лога необходимо использовать опцию конфигурационного файла *Modules/params_log*. Эта опция задает имя файла, куда будет записан лог с параметрами функций.

Выходной файл содержит диапазоны адресов и типы операций, выполненных с помеченными данными (r=чтение, w=запись). Также выводится стек вызовов на момент выхода из функции.

Фрагмент выходного файла:

```text
0xffffffff82dfc6f0 vmlinux:eth_type_trans
    0xffff88800e723840 8 bytes r
    0xffff88800e72384c 2 bytes r
    enter_icount: 58799550862
    exit_icount: 58799551027
    0: ffffffff82dfc963 in func ffffffff82dfc6f0 vmlinux::eth_type_trans
    1: ffffffff827cd3b6 in func ffffffff827ccec0 vmlinux::e1000_clean_rx_irq
    2: ffffffff827d544c in func ffffffff827d4c50 vmlinux::e1000_clean
    3: ffffffff82d1ea25 in func ffffffff82d1e6c0 vmlinux::net_rx_action
    4: ffffffff83a001b0 in func ffffffff83a00000 vmlinux::__do_softirq
    5: ffffffff83800f8d
0xffffffff81232e20 vmlinux:lock_acquire
    0xffff88806d009a90 8 bytes rw
    enter_icount: 58799552881
    exit_icount: 58799554333
    0: ffffffff81232ffd in func ffffffff81232e20 vmlinux::lock_acquire
    1: ffffffff8302c830 in func ffffffff8302c670 vmlinux::inet_gro_receive
    2: ffffffff82d200cb in func ffffffff82d1f440 vmlinux::dev_gro_receive
    3: ffffffff82d22885 in func ffffffff82d22680 vmlinux::napi_gro_receive
    4: ffffffff827cd485 in func ffffffff827ccec0 vmlinux::e1000_clean_rx_irq
    5: ffffffff827d544c in func ffffffff827d4c50 vmlinux::e1000_clean
    6: ffffffff82d1ea25 in func ffffffff82d1e6c0 vmlinux::net_rx_action
    7: ffffffff83a001b0 in func ffffffff83a00000 vmlinux::__do_softirq
    8: ffffffff83800f8d
```

## <a name="functional_coverage"></a>9.4. Анализ покрытия бинарного кода

Плагин *coverage* используется для сбора покрытия исполняемого кода.

Опции плагина:

- *file* -
Задаёт название файла, куда будут записываться данные о покрытии кода (по умолчанию *coverage.cov64*)
- *taint* - Позволяет переключать режимы сбора покрытия. Если установлено значение *true*, то плагин будет собирать данные о покрытии только для помеченных данных. Если значение параметра не установлено или установлено в *false*, плагин будет собирать данные о покрытии для всех базовых блоков, которые были выполнены и относятся к какому-либо модулю (данный плагин не собирает покрытия для базовых блоков, которые не относятся ни к одному модулю).
- *txt* - Предоставляет возможность выбора формата сохранения данных о покрытии кода. Если значение установлено в *true*, данные сохраняются в текстовом формате. Если значение не указано или установлено в *false*, данные сохраняются в бинарном формате.

Для сбора покрытия необходимо раскомментировать секцию *[Coverage]* в главном конфигурационном файле *Natch* и присвоить значения указанным выше параметрам.

Для удобного анализа бинарного выходного файла можно воспользоваться скриптом *coverage.py*, который раскрашивает выполненный код в IDA Pro и выводит таблицу с покрытием функций. На данный момент скрипт протестирован и гарантированно работает на версиях 7.2 и 7.6, теоретически и на тех, что между ними.

С помощью плагина к *IDA Pro* можно смотреть:

* какие функции в наибольшей степени взаимодействовали с помеченными данными
* покрытие по базовым блокам функций, взаимодействовавших с помеченными данными

Чтобы использовать скрипт *coverage.py*, необходимо:

1. Открыть интересующий двоичный файл в IDA Pro.
2. Для совпадения адресов в Qemu и IDA Pro необходимо выполнить Rebase (Edit -> Segments -> Rebase program). Рекомендуется использовать адрес начала модуля.
3. Запустить выполнение скрипта *coverage.py* (File -> Script file).
4. Выбрать файл с интересующим покрытием в формате *.cov64*.
5. В появившемся окне выбрать интересующие процессы.

В ходе его выполнения скрипта может потребоваться ручное сопоставление модуля, для которого собрано покрытие, с модулем, загруженным в *IDA Pro*. Наиболее явная причина -- несовпадение имён исполняемого файла и файла, распознанного *Natch*. Пример такого несовпадения приведён на рисунке ниже:

<img src=images/coverage/ida1.png><figcaption>_Пример несовпадения имен модулей_</figcaption>

После выполнения маппинга в представленном выше меню в ручном режиме мы увидим приблизительно следующие сведения о покрытии:

<img src=images/coverage/ida2.png><figcaption>_Загруженный проект_</figcaption>

Также при выборе функции можно увидеть покрытие непосредственно по ассемблерным инструкциям (голубой цвет):

<img src=images/coverage/coverage.png><figcaption>_Пример покрытия по ассемблерным инструкциям_</figcaption>

Демонстрация покрытия по декомпилированному коду в настоящий момент не поддерживается.

## <a name="func_args"></a>9.5. Получение аргументов вызываемых функций

*Natch* предоставляет бета-возможность получения корпуса данных для фаззинга. На данный момент поддерживаются только простые типы аргументов, а именно, целочисленные значения, числа с плавающей запятой и null-терминированные строки (char \*). Если встречается аргумент, не соответствующий этим требованиям, то возможны два сценария: если аргумент был передан по ссылке или является указателем, то он будет пропущен и анализ будет продолжен; в противном случае, он и все последующие аргументы не будут проанализированы.

Для включения этой возможности необходимо записать сценарий и, в сгенерированном конфигурационном файле сценария (`taint.cfg`), раскомментировать секцию *[FunctionArgs]*,
где в поле *config* следует указать имя конфигурационного файла с подобным содержимым:

```ini
[Func1]
name=load_file

[Func2]
name=do_curl
```
Вышепредставленный конфигурационный файл на данный момент не генерируется автоматически, а должен быть создан пользователем вручную. В примере *load_file* и *do_curl* это названия функций, для которых будут собираться значения аргументов. Созданный конфигурационный файл следует поместить в папку со сценарием, а в конфигурационном файле сценария написать имя без пути.
Фрагмент конфигурационного файла сценария:
```ini
[FunctionArgs]
config=functions.cfg
```

Если список функций заранее известен, то *Natch* можно запустить в облегченном варианте без отслеживания помеченных данных, для этого в секции *[Mode]* основного конфигурационного
файла *Natch* параметр *light* следует установить в *true*, таким образом, замедление будет минимизировано. Результат работы механизма будет помещен в папку *output_<scenario_name>*
в виде json файла с именем *args_info*.

В противном случае потребуется два запуска *Natch*: первый с целью анализа и выявления интересующих функций, а второй уже непосредственно для получения аргументов.

Пример полученного результата для тестового сценария *sample_test*:
```json
[
    {
        "Function name": "load_file",
        "Function qualified name": "_ZN4pugi12xml_document9load_fileEPKcjNS_12xml_encodingE",
        "Arguments": [
            {
                "Name": "this",
                "Skipped": "Too hard to Natch"
            },
            {
                "Name": "path_",
                "Type": "char *",
                "Size": 0,
                "Value": "86\uFFFD\uFFFD\uFFFD\u007F"
            },
            {
                "Name": "options",
                "Type": "unsigned int",
                "Size": 4,
                "Value": 1763360900
            },
            {
                "Name": "encoding",
                "Type": "unsigned int",
                "Size": 4,
                "Value": 116
            }
        ]
    },
    {
        "Function name": "do_curl",
        "Arguments": [
            {
                "Name": "str",
                "Type": "char *",
                "Size": 0,
                "Value": "www.google.com"
            }
        ]
    }
]
```

Чтобы преобразовать квалифицированное имя функции (Function qualified name) в удобочитаемый вид, можно использовать скрипт `func_info_demangle.py`.
Этот скрипт находится в директории *plugins_isp/sources/natch/scripts*. Он принимает входной файл в формате JSON и выполняет преобразование
квалифицированного имени в форму, понятную человеку.

