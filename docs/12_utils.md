<div style="page-break-before:always;">
</div>

# <a name="utils"></a>12. Полезные утилиты и скрипты Natch

В комплект поставки *Natch* входит несколько вспомогательных утилит, которые могут пригодиться в некоторых ситуациях,
например, небольшие изменения настроек проекта (чтобы не править скрипты запуска руками), или добавление новых бинарных файлов
в конфигурационный файл модулей.

Помимо утилит в этом разделе приведено описание скриптов, которые автоматически
вызываются в процессе создания проекта, но, при необходимости, могут быть использованы и отдельно в
рамках уже готового проекта.

## 12.1. Утилиты для настройки проекта

### <a name="natch_append_modules"></a>12.1.1. Пополнение конфигурационного файла module.cfg

При работе с инструментом может возникнуть желание дополнить список модулей, указанных при настройке проекта.
Для этого можно использовать скрипт `append_module_config.py`, расположенный в папке `utils` (полный путь: `/usr/bin/natch/bin/natch_scripts/utils`).

```bash
append_module_config.py [-h] [-d WORKDIR] [-D MODULEDIR] -i IMAGE
```

Скрипт принимает ряд параметров:

- `-D`
  Путь к директории с новыми модулями.
- `-i`
  Путь к образу гостевой операционной системы (*обязательный*).
- `-d`
  Путь к рабочей директории. Если скрипт запускается не из нее, то следует указать.

В процессе работы скрипта будет проанализирован каталог с новыми модулями, исследованы зависимости и скачана информация о библиотечных модулях (если есть), а так же перестроена символьная информация.
Если на этапе конфигурирования проекта не была скачана отладочная информация для ядра и интерпретаторов, то здесь есть возможность это исправить (будет задан соответствующий вопрос).

Для работы потребуется пароль администратора для монтирования образа. На выходе получим новый `module.cfg` и обновленные каталоги с информацией о модулях.

### <a name="natch_change_settings"></a>12.1.2. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны следующие параметры: размер оперативной памяти, проброшенные порты, режим работы эмулятора.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS] [-t TEXT_MODE]
```
Все параметры являются опциональными.

- `-d`
  Путь к рабочей директории. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- `-m`
  Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- `-p`
  Проброшенные порты. Указать список новых портов для проброса через запятую без пробелов. Прошлый список будет заменен.
  Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и конфигурационные файлы инструмента (при желании).
- `-t`
  Режим работы эмулятора. Предполагается два режима - графический и текстовый. Чтобы переключиться в текстовый режим следует использовать аргумент *yes*, в противном случае - *no*.

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343 -t no
```
Такой запуск приведет к изменению скриптов запуска (`run_qemu.sh`, `run_record.sh`, `run_replay.sh`), а так же будет предложено выбрать в каких сценариях следует внести изменения и в конфигурационные файлы. Если такие изменения не требуются - нужно нажать клавишу *ESC*.


## 12.2. Утилиты для работы с образом

### <a name="copy_files">12.2.1. Копирование файлов из гостевой системы

Во время подготовки объекта оценки для анализа часто возникает необходимость извлечь бинарные файлы из образа
в хостовую систему. Для этого есть разные способы, одним из которых является скрипт `copy_files.py` (находится в папке `guest_system`).

Скрипт принимает ряд параметров:

```bash
copy_files.py [-h] [-l LOG] [-d] img dest paths [paths ...]
```

- `img`
  Путь к образу гостевой операционной системы (*обязательный*).

- `dest`
  Путь к директории, в которую будут сохранены копируемые файлы (*обязательный*).

- `paths`
  Список, содержащий пути до файлов/директорий (*обязательный*).

- `-l, --log`
  Путь к файлу, в который будет записан журнал работы.

- `-d, --debug`
  Флаг включения диагностических сообщений.

Пример запуска скрипта:
```bash
sudo ./copy_files.py <path_to_img> <path_to_dest_folder> <list_paths_to_copy>
```
Обратите внимание на необходимость запуска скрипта с правами суперпользователя.


## 12.3. Вспомогательные скрипты Natch

Этот раздел посвящен описанию скриптов, которые используются при создании проекта и имеют определенные роли.
Информация скорее справочная, потому что нет необходимости запускать их самостоятельно.
Дополнительные настройки лучше проводить с помощью утилит, описанных выше.

Если же необходимость все-таки возникла, то нужно знать и помнить, что они взаимосвязаны и описаны в том
порядке, в каком следует их запускать.

### 12.3.1. Автоматическая генерация конфигурационного файла

Конфигурационный файл со списком модулей может быть сгенерирован автоматически при помощи входящего в поставку скрипта `module_config.py`
во время выполнения скрипта `natch_run.py` (подробнее в разделе [Использование скрипта для создания проекта](6_create_project.md#natch_run_script)).

Скрипт `module_config.py` принимает ряд параметров:

```bash
module_config.py folder [-h] [-l] [-d]
```

- `folder`
  Путь к директории, содержащей модули и map-файлы (*обязательный*).

- `-o`
  Название генерируемого конфигурационного файла (По умолчанию: *module.cfg*)

- `-d`
  Флаг включения диагностических сообщений

- `-l`
  Путь к рабочей директории, в которую будет помещен лог работы инструмента. По умолчанию в месте запуска скрипта.

Если используются map-файлы, то имена map и исполняемых файлов должны соответствовать друг другу:
скрипт будет искать map-файлы, приписывая суффикс .map к полному имени исполняемого файла.

Пример запуска скрипта:
```bash
./module_config.py <path_to_modules>
```

### <a name="debug_info"></a>12.3.2. Автоматическая загрузка отладочной информации для разделяемых библиотек

В поставку инструмента входит скрипт `debug_info.py` (находится в папке `guest_system/debuginfo_collector`),
позволяющий получить символьную информацию из системных библиотек, работавших с исследуемыми приложениями.
В процессе выполнения скрипта для каждого исполняемого файла происходит поиск необходимых для него разделяемых библиотек.
Для всех найденных библиотек загружается отладочная информация, если она доступна.
На выходе получается новый конфигурационный файл `module.cfg`, дополненный найденными библиотеками с отладочной информацией.

Для запуска данного скрипта, потребуется заранее сгенерированный конфигурационный файл `debug_info.cfg`, содржащий в себе следующие секции:

**Секция Common**

Данная секция является обязательной и содержит в себе поля, которые непосредственно влияют на все этапы процесса загрузки отладочных символов.

- Поле *attempts*: является обязательным и определяет число итераций, в ходе которых скрипт пытается осуществить доступ к различным интернет-ресурсам. В случае временной недоступности указанных ресурсов скрипт ожидает определенный промежуток времени перед повторной попыткой обращения к ним.

- Поле *mount*: определяет необходимость монтирования гостевой системы и, по умолчанию, имеет значение True. В случае, если гостевой образ не может быть смонтирован по каким-либо причинам, можно запустить данный скрипт в Лёгком режиме, установив данный параметр в значение False. При этом дальнейший анализ ограничивается исключительно поиском отладочных символов для модулей, указанных в конфигурационном файле хостовой системы. Этот поиск может осуществляться либо в пользовательской директории, либо с использованием сервиса DebugInfoD, при условии, что пользователь дал на это согласие. Указание параметра False препятствует автоматическому определению типа операционной системы гостя. Рекомендуется указать сервера для сервиса DebugInfoD, соответствующие вашей операционной системе.

- Поле *debug*: флаг включения диагностических сообщений, по умолчанию, имеет значение False.

**Секция Configs**

Данная секция является обязательной и включает в себя информацию о конфигурационных файлах, используемых для модулей.

- Поле *host*: является обязательным и содержит путь к конфигурационному файлу, в котором перечислены пути до модулей, которые были выгруженны из гостевой ОС и находятся в хостовой.
- Поле *guest*: содержит путь к конфигурационному файлу, в котором перечислены пути до модулей, которые находятся в гостевой ОС.

**Секция UserFolder**

При активации данной секции, перечень доступных методов для поиска отладочных символов будет дополнен поиском в директории, указанной пользователем. Оставьте эту секцию закомментированной или удалите её, если этого не требуется.

- Поле *path*: является обязательным и содержит путь к пользовательской директории, в которой хранятся отладочные символы. Структура переданной директории должна соответствовать требованиям операционной системы к директории, в которую устанавливаются отладочные символы.

**Секция DebugInfoD**

При активации данной секции, перечень доступных методов для поиска отладочных символов будет дополнен сервисом DebugInfoD, если ваша гостевая ОС поддерживает его. Оставьте эту секцию закомментированной или удалите её, если этого не требуется.

- Поле *servers*: содержит пользовательский список серверов, специфических для конкретных операционных систем. Сервера по умолчанию установлены для операционных систем Ubuntu, Fedora, Alt и Debian. Формат указания: servers=['https://example1.com', 'https://example2.com'].

**Секция PackageAnalysis**

При активации данной секции, перечень доступных методов для поиска отладочных символов будет дополнен методом пакетного анализа гостевой операционной системы, если он был реализован для вашей гостевой ОС. На данный момент это: Ubuntu, Fedora, Alt 10 и Alpine (работает с последними версиями пакетов). Оставьте эту секцию закомментированной или удалите её, если этого не требуется.

- Поле *path_to_save_pkg_list*: содержит путь к файлу, в который будет экспортирован список пакетов, требующих отладочной информации. Одним из возможных сценариев использования этого списка является сбор указанных в нем пакетов в гостевой операционной системе с отладочными символами, а затем повторный запуск данного скрипта. Обратите внимание, при использовании данной опции отладочные пакеты не будут загружены этим методом.

**Секция Symbols**

Данная секция является обязательной и содержит информацию о дополнительных символах, которые следует загружать.

- Поле *kernel*: флаг разрешения загрузки символьной информации для ядра. При установке соответствующего флага, скрипт позволяет выкачивать из образа ядро вместе с его символьной информацией. Если не удалось определить, какое ядро используется, то выкачивается информация для всех ядер, найденных в каталоге `\boot`.

- Поле *python*: флаг разрешения загрузки символьной информации для Python интерпретаторов.

- Поле *csharp*: флаг разрешения загрузки символьной информации для C#.

- Поле *java*: флаг разрешения загрузки символьной информации для Java.

В дополнение к описанным выше методам поиска отладочных символов, если гостевая система была смонтирована, автоматически происходит поиск уже установленных отладочных символов в директории по умолчанию (/usr/lib/debug) для всех типов гостевых операционных систем.

Скрипт принимает ряд параметров:

```bash
sudo debug_info.py [-h] cfg_path img workdir
```

- `cfg_path`
  Путь к конфигурационному файлу (*обязательный*).

- `img`
  Путь к образу гостевой операционной системы (*обязательный*).

- `workdir`
  Рабочая директория скрипта (*обязательный*).

В результате выполнения скрипта в рабочей директории будет создана директория *debug_info*. Внутри нее будут созданы поддиректории *guest_libs* и *host_libs*, где будут храниться файлы, найденные в гостевом и хостовом конфигурационных файлах соответственно. В каждой из этих поддиректорий будут находиться директории *libs* и *dwz* (если были обнаружены дополнительные отладочные символы). Каждая из этих директорий будет содержать поддиректории с md5-хешем файла, находящегося в этой директории. Отладочные символы будут располагаться в директории с тем же хешем, что и модуль, к которому они относятся.

Не все библиотеки могут быть обнаружены, а именно, библиотеки, загружаемые во время выполнения с помощью `dlopen` и других похожих механизмов, не могут быть определены статически, поэтому они будут пропущены.

В случае возникновения ошибки монтирования, следует выполнить следующие действия:

* Проверьте, не используется ли данный образ другими программами или не был ли он смонтирован ранее.
* Проверьте, не запущена ли виртуальная машина, например, VirtualBox.
* Убедитесь, что все требуемые зависимости установлены: выполните команду sudo pip3 install -r guest_system/requirements.txt.
* Попробуйте смонтировать образ вручную с использованием команды sudo guestmount -a *img_path* -i *mount_point* --rw. Исправьте ошибки, если это возможно. Для размонтирования образа используйте команду sudo guestunmount *mount_point*.

Пример запуска скрипта:
```bash
sudo ./debug_info.py <path_to_debug_info_config> <path_to_system_img> <path_to_workdir>
```
Обратите внимание на необходимость запуска скрипта с правами суперпользователя.

### <a name="symbol_info"></a>12.3.3. Получение символьной информации из исполняемых файлов

После того как файл `module.cfg` полностью готов, необходимо получить символьную информацию из исполняемых файлов
и записать ее в специальный каталог vmidb. Для этого предназначен скрипит *symbol_info.py*.

Так же его нужно запускать после обновления *Natch* или добавления новых файлов в конфиг `module.cfg`.

Скрипт принимает ряд параметров:

```bash
symbol_info.py [-h] [-d] cfg_path workdir
```

- `cfg_path`
  Путь к конфигурационному файлу module.cfg (*обязательный*).

- `workdir`
  Рабочая директория проекта (*обязательный*).

- `-d, --debug`
  Флаг включения диагностических сообщений.




