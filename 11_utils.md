<div style="page-break-before:always;">
</div>

# <a name="utils"></a>11. Полезные утилиты и скрипты Natch

В комплект поставки *Natch* входит несколько вспомогательных утилит, которые могут пригодиться в некоторых ситуациях,
например, небольшие изменения настроек проекта (чтобы не править скрипты запуска руками), или добавление новых бинарных файлов
в конфигурационный файл модулей.

Помимо утилит в этом разделе приведено описание скриптов, которые автоматически
вызываются в процессе создания проекта, но, при необходимости, могут быть использованы и отдельно в
рамках уже готового проекта.

## 11.1. Утилиты для настройки проекта

### <a name="natch_append_modules"></a>11.1.1. Пополнение конфигурационного файла module.cfg

При работе с инструментом может возникнуть желание дополнить список модулей, указанных при настройке проекта.
Для этого можно использовать скрипт `append_module_config.py`, расположенный в папке `utils` (полный путь: `/usr/bin/natch/bin/natch_scripts/utils`).

```bash
append_module_config.py [-h] [-d WORKDIR] -D MODULEDIR -i IMAGE
```

Скрипт принимает ряд параметров:

- `-D`
  Путь к директории с новыми модулями (*обязательный*).
- `-i`
  Путь к образу гостевой операционной системы (*обязательный*).
- `-d`
  Путь к рабочей директории. Если скрипт запускается не из нее, то следует указать.

В процессе работы скрипта будет проанализирован каталог с новыми модулями, исследованы зависимости и скачана информация о библиотечных модулях (если есть), а так же перестроена символьная информация.
Если на этапе конфигурирования проекта не была скачана отладочная информация для ядра и интерпретаторов, то здесь есть возможность это исправить (будет задан соответствующий вопрос).

Для работы потребуется пароль администратора для монтирования образа. На выходе получим новый `module.cfg` и обновленные каталоги с информацией о модулях.

### <a name="natch_change_settings"></a>11.1.2. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны следующие параметры: размер оперативной памяти, проброшенные порты, режим работы эмулятора.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS] [-t TEXT_MODE]
```
Все параметры являются опциональными.

- `-d`
  Путь к рабочей директории. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- `-m`
  Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- `-p`
  Проброшенные порты. Указать список новых портов для проброса через запятую без пробелов. Прошлый список будет заменен.
  Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и конфигурационные файлы инструмента (при желании).
- `-t`
  Режим работы эмулятора. Предполагается два режима - графический и текстовый. Чтобы переключиться в текстовый режим следует использовать аргумент *yes*, в противном случае - *no*.

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343 -t no
```
Такой запуск приведет к изменению скриптов запуска (`run_qemu.sh`, `run_record.sh`, `run_replay.sh`), а так же будет предложено выбрать в каких сценариях следует внести изменения и в конфигурационные файлы. Если такие изменения не требуются - нужно нажать клавишу *ESC*.


## 11.2. Утилиты для работы с образом

### <a name="copy_files">11.2.1. Копирование файлов из гостевой системы

Во время подготовки объекта оценки для анализа часто возникает необходимость извлечь бинарные файлы из образа
в хостовую систему. Для этого есть разные способы, одним из которых является скрипт `copy_files.py` (находится в папке `guest_system`).

Скрипт принимает ряд параметров:

```bash
copy_files.py [-h] [-l LOG] [-d] img dest paths [paths ...]
```

- `img`
  Путь к образу гостевой операционной системы (*обязательный*).

- `dest`
  Путь к директории, в которую будут сохранены копируемые файлы (*обязательный*).

- `paths`
  Список, содержащий пути до файлов/директорий (*обязательный*).

- `-l, --log`
  Путь к файлу, в который будет записан журнал работы.

- `-d, --debug`
  Флаг включения диагностических сообщений.


При копировании директории вложенность удаляется, т.е все файлы будут скопированы в корень указанной директории.

Пример запуска скрипта:
```bash
sudo ./copy_files.py <path_to_img> <path_to_dest_folder> <list_paths_to_copy>
```
Обратите внимание на необходимость запуска скрипта с правами суперпользователя.


## 11.3. Вспомогательные скрипты Natch

Этот раздел посвящен описанию скриптов, которые используются при создании проекта и имеют определенные роли.
Информация скорее справочная, потому что нет необходимости запускать их самостоятельно.
Дополнительные настройки лучше проводить с помощью утилит, описанных выше.

Если же необходимость все-таки возникла, то нужно знать и помнить, что они взаимосвязаны и описаны в том
порядке, в каком следует их запускать.

### 11.3.1. Автоматическая генерация конфигурационного файла

Конфигурационный файл со списком модулей может быть сгенерирован автоматически при помощи входящего в поставку скрипта `module_config.py`
во время выполнения скрипта `natch_run.py` (подробнее в разделе [Использование скрипта для создания проекта](5_create_project.md#natch_run_script)).

Скрипт `module_config.py` принимает ряд параметров:

```bash
module_config.py folder [-h] [-l] [-d]
```

- `folder`
  Путь к директории, содержащей модули и map-файлы (*обязательный*).

- `-d`
  Флаг включения диагностических сообщений

- `-l`
  Путь к рабочей директории, в которую будет помещен лог работы инструмента. По умолчанию в месте запуска скрипта.

Если используются map-файлы, то имена map и исполняемых файлов должны соответствовать друг другу:
скрипт будет искать map-файлы, приписывая суффикс .map к полному имени исполняемого файла.

Пример запуска скрипта:
```bash
./module_config.py <path_to_modules>
```

### <a name="debug_info"></a>11.3.2. Автоматическая загрузка отладочной информации для разделяемых библиотек

В поставку инструмента входит скрипт `debug_info.py` (находится в папке `guest_system/debuginfo_collector`),
позволяющий получить символьную информацию из системных библиотек, работавших с исследуемыми приложениями.
В процессе выполнения скрипта для каждого исполняемого файла происходит поиск необходимых для него разделяемых библиотек.
Для всех найденных библиотек загружается отладочная информация, если она доступна.
На выходе получается новый конфигурационный файл `module.cfg`, дополненный найденными библиотеками с отладочной информацией.

При установке соответствующего флага, скрипт позволяет выкачивать из образа ядро вместе с его символьной информацией.
Если не удалось определить, какое ядро используется, то выкачивается информация для всех ядер, найденных в каталоге `\boot`.

Если в вашем анализируемом образе присутствует код на Python или Java, рекомендуется установить соответствующие флаги,
разрешающие загрузку символьной информации для каждого из языков.

Если имеется директория, содержащая файлы отладочной информации для разделяемых библиотек, поставляемых с операционной системой,
то можно включить данную директорию в скрипт, используя опцию, указанную ниже. В случае, если в гостевой системе уже установлены
отладочные пакеты, и каталог с ними находится по умолчанию `(/usr/lib/debug)`, выгрузка его из гостевой системы не требуется,
поскольку поиск в этом каталоге будет выполнен автоматически.

Скрипт принимает ряд параметров:

```bash
debug_info.py [-h] [-d] [-s SAVE] [-k] [-i] [-j] [-D DEBUG_PKG] cfg_path img
```

- `cfg_path`
  Путь к конфигурационному файлу (*обязательный*).

- `img`
  Путь к образу гостевой операционной системы (*обязательный*).

- `-d, --debug`
  Флаг включения диагностических сообщений.

- `-s, --save`
  Путь к директории, в которую будут сохранены разделяемые библиотеки и их отладочные символы. (По умолчанию: *текущая директория*).

- `-D, --debug_pkg`
  Путь к директории, в которой содержатся отладочная информация(.debug) для разделяемых библиотек.

- `-k, --kernel`
  Флаг разрешения загрузки символьной информации для ядра.

- `-i, --interp`
  Флаг разрешения загрузки символьной информации для Python интерпретаторов.

- `-j, --java`
  Флаг разрешения загрузки символьной информации для Java.


Найденные библиотеки и их отладочная информация будут помещены в папку *libs* в месте запуска скрипта, если не была указана другая локация.

Не все библиотеки могут быть обнаружены, а именно, библиотеки, загружаемые во время выполнения с помощью `dlopen` и других похожих механизмов,
не могут быть определены статически, поэтому они будут пропущены.

В случае ошибки монтирования убедитесь, что не смонтированы другие образы или же не запущена виртуальная машина (например, VirtualBox).

В данный момент скрипт работает с гостевыми системами:

- Ubuntu 20.04 и выше (будет работать и с младшими версиями, однако увеличится количество ненайденных отладочных символов)
- Fedora 33 и выше (будет работать и с младшими версиями, однако увеличится количество ненайденных отладочных символов)
- Debian 11 и выше (версии ниже не тестировались)
- Alpine (работает с последними версиями пакетов)
- Alt 10

Также скрипт будет работать с дистрибутивами Linux, основанных на `glibc`, которые поддерживают службу `Debuginfod`.

Пример запуска скрипта:
```bash
sudo ./debug_info.py <path_to_module_config> <path_to_system_img>
```
Обратите внимание на необходимость запуска скрипта с правами суперпользователя.

### <a name="symbol_info"></a>11.3.3. Получение символьной информации из исполняемых файлов

После того как файл `module.cfg` полностью готов, необходимо получить символьную информацию из исполняемых файлов
и записать ее в специальный каталог vmidb. Для этого предназначен скрипит *symbol_info.py*.

Так же его нужно запускать после обновления *Natch* или добавления новых файлов в конфиг `module.cfg`.

Скрипт принимает ряд параметров:

```bash
symbol_info.py [-h] [-d] cfg_path workdir
```

- `cfg_path`
  Путь к конфигурационному файлу module.cfg (*обязательный*).

- `workdir`
  Рабочая директория проекта (*обязательный*).

- `-d, --debug`
  Флаг включения диагностических сообщений.




