<div style="page-break-before:always;">
</div>

# <a name="natch_run_main"></a>4. Запуск Natch

В комплект поставки инструмента *Natch* входят документация и исполняемые файлы. Исполняемые файлы разделены на две категории - собственно исполняемые файлы *Natch* и комплект необходимых для работы разделяемых библиотек. При запуске на машине без установленных библиотек может потребоваться явно указать путь к библиотекам, используя механизм `LD_PRELOAD`, а именно определить переменную *LD_LIBRARY_PATH*, указав ей путь к распакованному архиву с библиотеками следующим образом:
```bash
LD_LIBRARY_PATH=/path_to_libs ./natch_run.py path_to_image
```

Для работы *Natch* потребуется установка ряда зависимостей. Сделать это можно с помощью скрипта *setup_requirements.sh*, который находится в папке *natch_scripts*. В результате работы будут установлены python пакеты и deb пакет, необходимые для работы скриптов, входящих в поставку инструмента. В процессе работы потребуется пароль администратора.

## <a name="natch_run_script"></a>4.1. Использование скрипта для генерации командных строк запуска

В поставку инструмента входит скрипт *natch_run.py*, который нужен для генерации командных строк для запуска *Natch*, а так же для первоначальной настройки инструмента.

В процессе выполнения скрипта пользователь должен уточнять параметры запуска инструмента. На выходе сформируются три скрипта: *run_record.sh* и *run_replay.sh* для запуска *Natch* в режиме записи и
воспроизведения работы соответственно, а так же *run_qemu.sh* для запуска Qemu без *Natch*.

Инструмент *Natch* агрегирован в плагине *natch*, который подключается к Qemu.

Прежде чем перейти к описанию скрипта, рассмотрим опцию для подключения конфигурационного файла плагина *natch*.
- *config*
Задает файл конфигурации инструмента (подробнее в пункте [Основной конфигурационный файл](3_configs.md#main_config)).

Пример командной строки, отвечающей за подключение плагина с опцией *config*:
```
-plugin natch,config=natch.cfg
```
Скрипт *natch_run.py* имеет три параметра, один обязательный и два опциональных. Обязательный параметр это путь к образу системы, опциональные - путь к ядру (опция kernel эмулятора Qemu, если ядро ОС не загружается из образа системы) и название операционной системы, для которой будет использован инструмент (по умолчанию Linux, предоставляется выбор из следующих вариантов: Linux, FreeBSD, Win7). Так же скрипт можно запустить с опцией *-h* и получить справку по доступным опциям.

Описание команды и ее параметров представлено ниже:
```text
natch_run.py image [-h] [-k KERNEL] [-o {Linux, FreeBSD}]
```
Пример запуска скрипта:
```bash
LD_LIBRARY_PATH=/path_to_libs ./natch_run.py <image> -o Linux
```

Список вопросов, которые будут заданы при выполнении скрипта:
- *Путь к директории проекта* \
Необходимо указать полный путь или только название папки, которая будет создана для хранения всех скриптов, конфигураций и прочих файлов инструмента.
Внутри этой директории будет создана еще одна папка с именем *output*, в которую будут помещены выходные файлы работы инструмента.
Параметр является опциональным, в случае пропуска рабочий каталог будет называться именем запускаемого образа гостевой системы.
Если каталог уже существует, будет создан новый с постфиксом *_х*, где x - это число от 1 до максимально возможного.

- *Количество оперативной памяти* \
Необходимо указать объем оперативной памяти, выделяемый виртуальной машине. Указывается число в гигабайтах или мегабайтах с соответствующим постфиксом G или M, например 512M.

- *Сетевые опции* \
В этом меню пользователь может указать порты, которые необходимо пробросить в виртуальную машину. Запрос на ввод портов появится при выборе ответа *Y/y* или при нажатии клавиши *Enter*. Кроме того, будет предложено помечать не только Destination ports, но и Source. Если это необходимо, следует выбрать ответ *Y/y* или нажать клавишу *Enter*. Порты следует указывать через запятую. Указываемые порты должны лежать в диапазоне [1 .. 9999]. Порт для обращения к машине извне будет формироваться по принципу: *user_port + 10000*.

После этих вопросов скрипт попробует обратиться к утилите *qemu-img*, входящей в поставку эмулятора Qemu, чтобы создать оверлей для образа, необходимый для хранения состояний системы. Если оверлей создать не удалось, выполнение скрипта будет прервано.

Далее скрипт предложит создать конфигурационный файл для модулей. Если модули есть в наличии, то следует согласиться, в противном случае ввести *n* или *N*. Если конфигурационный файл нужен, будет предложено ввести путь к папке, содержащей модули. Так как генерация конфигурационного файла может занять продолжительное время, этот процесс будет запущен параллельно. По окончании настроек будет предложено или ознакомиться с логом процесса генерации или подождать завершения процесса, а уже затем ознакомиться с логом (если сообщения о просмотре лога не будет, значит он пустой и все прошло великолепно).

Следующий вопрос коснется конфигурационного файла *task.cfg*. Если вы впервые создаете конфигурацию для образа, следует воспользоваться ответом по умолчанию (да). На этом этапе будет запущен эмулятор для извлечения информации о структурах ядра. Если же вы уже работали с этим образом и получали конфигурационный файл с этого этапа - вопрос можно пропустить, но не забудьте скопировать *task.cfg* в рабочую директорию нового проекта. Если не уверены, что файл от нужного образа - лучше ответить да и дождаться генерации файла.

В случае если был выбран конфиг для модулей, пользователю предложат скачать отладочные символы для системных библиотек, от которых зависит его приложение, и символы ядра операционной системы. Для выполнения этой операции потребуется пароль для sudo. Кроме того, если не все зависимости были установлены, то скрипт предложит установить нужные пакеты, для этого так же потребуется пароль для sudo. В случае нештатных ситуаций пользователь получит соответствующие сообщения, а произвести скачивание символов можно будет отдельно, воспользовавшись скриптом ``debug_info.py`` (подробнее в пункте [Автоматическая загрузка отладочной информации для разделяемых библиотек](3_configs.md#debug_info)).

Важные вопросы для пользователя закончились, далее при необходимости будет осуществлен настроечный запуск эмулятора, следует подождать пока он отработает и окно эмулятора закроется.

Если конфигурационный файл для модулей успел построиться, пользователь увидит вопрос с предложением ознакомиться с логом, если модули все еще анализируются, будет выведено сообщение `Waiting for module config generating`. Следует дождаться окончания работы скрипта. После чего можно посмотреть лог или оказаться от просмотра.
На этом настройка окончена.

Кроме командных строк будет сгенерирована заготовка конфигурационного файла *Natch*. В полученном файле описаны все возможные секции и поля с примерами заполнения, часть из которых закомментирована. При необходимости этот файл можно отредактировать -
раскомментировать нужные секции и внести актуальные значения параметров. Имя конфигурационного файла задается по умолчанию, а именно *natchg.cfg*.

Помимо скрипта *natch_run.py* в поставку инструмента входит скрипт *module_config.py*. Этот скрипт запускается внутри основного, если пользователь соглашается создать конфигурационный файл для модулей. При необходимости его можно использовать отдельно, если, например, модули обновились, а проводить заново настройку инструмента не нужно.

Скрипт *natch_run.py* расположен в директории *natch_scripts*. Запускать скрипт можно из любого расположения, готовые скрипты для запуска инструмента и все конфигурационные файлы будут помещены в рабочей директории, указанной пользователем или назначенной автоматически.

### 4.1.1. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны два параметра: размер оперативной памяти и проброшенные порты.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS]
```
Все параметры являются опциональными.

- Директория. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- Проброшенные порты. Указать список новых портов для проброса через запятую. Прошлый список будет заменен. Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и основной конфигурационный файл инструмента.

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343
```



## 4.2. Подготовка запуска Natch вручную

Скрипт *natch_run.py* призван упростить пользователю работу с инструментом, однако можно формировать командные строки для запуска самостоятельно. Пример конфигурационного файла *Natch* можно взять из документации.

Пример командной строки для запуска *Natch*:

``./qemu-system-x86_64 -hda debian.qcow2 -m 6G -monitor stdio -netdev user,id=net0 -device e1000,netdev=net0 -os-version Linux -plugin natch,config=natch.cfg``

При первом ручном запуске *Natch* произойдет генерация конфигурационного файла *task.cfg*. Следует дождаться завершения работы эмулятора, после чего можно запускать его для работы.

Однако, рекомендуемым вариантом использования *Natch* является его запуск с использованием детерминированного вопроизведения.

## 4.3. Запуск Natch с использованием детерминированного воспроизведения

Детерминированное воспроизведение состоит и двух фаз: запись и воспроизведение. Во время записи необходимо выполнить сценарий, который будет анализироваться во время следующих запусков в режиме воспроизведения.

При использовании скрипта для генерации командных строк, строки запуска для записи и воспроизведения будут получены автоматически: *run_record.sh* для записи и *run_replay.sh* для воспроизведения.

Таким образом для работы с *Natch* нужно записать сценарий работы виртуальной машины с помощью скрипта *run_record.sh* и воспроизводить его в дальнейшем с помощью скрипта *run_replay.sh*.

Скрипт *run_replay.sh* имеет необязательный параметр *snapshot_name*. Например, если во время записи был сохранен снэпшот с именем *load*, то запустить воспроизведение с этого момента можно либо передав скрипту параметр ``./run_replay.sh load``, либо отредактировав скрипт путем замены значения переменной *SNAPSHOT* с *init* на *load*.

Непосредственно работа с инструментом *Natch* никак не изменится при использовании детерминированного воспроизведения. Изменения коснутся лишь строки запуска самого эмулятора.

Если по какой-то причине вы не используете скрипт *natch_run.py*, ниже приведен пример строк запуска эмулятора в режимах записи и воспроизведения.

Пример командной строки для записи работы:

```text
./qemu-system-x86_64 -m 4G \
-icount shift=5,rr=record,rrfile=replay.bin \
-drive file=debian10.qcow2,if=none,snapshot,id=img-direct \
-drive driver=blkreplay,if=none,image=img-direct,id=img-blkreplay \
-device ide-hd,drive=img-blkreplay \
-netdev user,id=net0 \
-device e1000,netdev=net0 \
-object filter-replay,id=replay,netdev=net0 \
-monitor stdio \
```

Пример командной строки для воспроизведения работы:

```text
./qemu-system-x86_64 -m 4G \
-icount shift=5,rr=replay,rrfile=replay.bin \
-drive file=debian10.qcow2,if=none,snapshot,id=img-direct \
-drive driver=blkreplay,if=none,image=img-direct,id=img-blkreplay \
-device ide-hd,drive=img-blkreplay \
-netdev user,id=net0 \
-device e1000,netdev=net0 \
-object filter-replay,id=replay,netdev=net0 \
-monitor stdio \
-plugin natch,config=natch.cfg \
```

## 4.4. Пометка файлов

*Natch* может помечать отдельные файлы в гостевой системе и отслеживать модули и функции, которые были затронуты в результате работы с ними. При этом берутся в расчет только операции чтения.

Исполняемые файлы помечаться таким способом не будут, так как они не открываются для чтения пользовательским кодом, а отображаются
прямо в адресное пространство ядерными функциями.
Аналогично не будет детектироваться работа драйвера жесткого диска с местом хранения заданного файла.

Включить плагин и задать необходимые для пометки файлы можно в основном конфигурационном файле *Natch*. Если секция *TaintFile* не была описана, для пометки файлов необходимо подключить плагин *taint_file*. Сделать это можно во время работы эмулятора командой монитора ``plugins_load taint_file``.

Плагин предоставляет набор функций, в частности, отслеживание файла включается командой ``taint_file <filename>``. Имя файла можно указывать без пути или с ним, но во втором случае он может быть не найден из-за особенностей реализации.

После этого необходимо повзаимодействовать с помеченным файлом и оценить результат с помощью команды ``natch_get_attack_surface <filename>`` или завершив работу эмулятора.

## 4.5. Пометка входящих сетевых пакетов

*Natch* способен помечать весь сетевой трафик, который приходит в виртуальную машину извне.
Пометка полностью локального трафика пока не поддерживается.

Для управления пометкой пакетов используется секция *[Ports]* конфигурационного файла (подробнее в пункте [Основной конфигурационный файл](3_configs.md#main_config) секция **Ports**).

Пакеты помечаются целиком, вместе с заголовком второго уровня.
Возможны следующие варианты работы:

* Помечать все входные пакеты. ip_protocol=-1 + (dst=-1 или src=-1)
* Помечать все UDP-пакеты. ip_protocol=17
* Помечать все TCP-пакеты. ip_protocol=6 + (dst=-1 или src=-1)
* Помечать все HTTP-пакеты от внешнего веб-сервера. ip_protocol=6 + src=80
* Помечать все ICMP-пакеты. ip_protocol=1
