<div style="page-break-before:always;">
</div>

# <a name="natch_run_main"></a>4. Запуск Natch

В комплект поставки инструмента *Natch* входят документация и исполняемые файлы. Исполняемые файлы разделены на две категории - собственно исполняемые файлы *Natch* и комплект необходимых для работы разделяемых библиотек. При запуске на машине без установленных библиотек может потребоваться явно указать путь к библиотекам, используя механизм `LD_PRELOAD`, а именно определить переменную *LD_LIBRARY_PATH*, указав ей путь к распакованному архиву с библиотеками следующим образом:
```bash
LD_LIBRARY_PATH=/path_to_libs ./natch_run.py path_to_image
```

Для работы *Natch* потребуется установка ряда зависимостей. Сделать это можно с помощью скрипта *setup_requirements.sh*, который находится в папке *natch_scripts*. В результате работы будут установлены python пакеты и deb пакет, необходимые для работы скриптов, входящих в поставку инструмента. В процессе работы потребуется пароль администратора.

## <a name="natch_run_script"></a>4.1. Использование скрипта для генерации командных строк запуска

В поставку инструмента входит скрипт *natch_run.py*, который нужен для генерации командных строк для запуска *Natch*, а так же для первоначальной настройки инструмента. Скрипт *natch_run.py* расположен в директории *natch_scripts*. Запускать скрипт можно из любого расположения, готовые скрипты для запуска инструмента и все конфигурационные файлы будут помещены в рабочей директории, указанной пользователем или назначенной автоматически.

В процессе выполнения скрипта пользователь должен уточнять параметры запуска инструмента. На выходе сформируются три скрипта: *run_record.sh* и *run_replay.sh* для запуска *Natch* в режиме записи и
воспроизведения работы соответственно, а так же *run_qemu.sh* для запуска Qemu без *Natch*.

Скрипт *natch_run.py* имеет три параметра, один обязательный и два опциональных. Обязательный параметр это путь к образу системы, опциональные - путь к ядру (опция kernel эмулятора Qemu, если ядро ОС не загружается из образа системы) и название операционной системы, для которой будет использован инструмент (по умолчанию Linux, предоставляется выбор из следующих вариантов: Linux, FreeBSD, Win7). Так же скрипт можно запустить с опцией *-h* и получить справку по доступным опциям.

Описание команды и ее параметров представлено ниже:
```text
natch_run.py image [-h] [-k KERNEL] [-o {Linux, FreeBSD}]
```
Пример запуска скрипта:
```bash
LD_LIBRARY_PATH=/path_to_libs ./natch_run.py <image> -o Linux
```

Список вопросов, которые будут заданы при выполнении скрипта:
- *Путь к директории проекта* \
Необходимо указать полный путь или только название папки, которая будет создана для хранения всех скриптов, конфигураций и прочих файлов инструмента.
Внутри этой директории будет создана еще одна папка с именем *output*, в которую будут помещены выходные файлы работы инструмента.
Параметр является опциональным, в случае пропуска рабочий каталог будет называться именем запускаемого образа гостевой системы.
Если каталог уже существует, будет создан новый с постфиксом *_х*, где x - это число от 1 до максимально возможного.

- *Количество оперативной памяти* \
Необходимо указать объем оперативной памяти, выделяемый виртуальной машине. Указывается число в гигабайтах или мегабайтах с соответствующим постфиксом G или M, например 512M.

- *Режим работы эмулятора* \
Эмулятор может быть запущен в графическом (обычном) или текстовом режиме. По умолчанию режим графический, если же необходимо работать в тестовом режиме следует дать ответ *n* или *N*. В этом случае потребуется дополнительная настройка вашего образа (в тестовом все настроено).

После этих вопросов скрипт попробует обратиться к утилите *qemu-img*, входящей в поставку эмулятора Qemu, чтобы создать оверлей для образа, необходимый для хранения состояний системы. Если оверлей создать не удалось, выполнение скрипта будет прервано.

- *Сетевые опции* \
В этом меню пользователь может указать порты, которые необходимо пробросить в виртуальную машину. Запрос на ввод портов появится при выборе ответа *Y/y* или при нажатии клавиши *Enter*. Кроме того, будет предложено помечать не только Destination ports, но и Source. Если это необходимо, следует выбрать ответ *Y/y* или нажать клавишу *Enter*. Порты следует указывать через запятую. Указываемые порты должны лежать в диапазоне [1 .. 9999]. Порт для обращения к машине извне будет формироваться по принципу: *user_port + 10000*.

- *Создание конфигурационного файла для модулей* \
Если модули есть в наличии, то следует нажать *Enter*, *y* или *Y*, в противном случае ввести *n* или *N*. Если конфигурационный файл нужен, будет предложено ввести путь к папке, содержащей модули. Так как генерация конфигурационного файла может занять продолжительное время, этот процесс будет запущен параллельно. По окончании настроек будет предложено или ознакомиться с логом процесса генерации или подождать завершения процесса, а уже затем ознакомиться с логом (если сообщения о просмотре лога не будет, значит он пустой и все прошло великолепно).

- *Генерация конфигурационного файла для ядерных сущностей* \
Следующий вопрос коснется конфигурационного файла *task.cfg*. Если вы впервые создаете конфигурацию для образа, следует воспользоваться ответом по умолчанию (да). На этом этапе будет запущен эмулятор для извлечения информации о структурах ядра. Если же вы уже работали с этим образом и получали конфигурационный файл с этого этапа - вопрос можно пропустить, но не забудьте скопировать *task.cfg* в рабочую директорию нового проекта. Если не уверены, что файл от нужного образа - лучше ответить да и дождаться генерации файла.

Если конфигурационный файл для модулей не успел построиться к этому моменту, будет выведено сообщение `Waiting for module config generating`. Следует дождаться окончания работы скрипта. Если в процессе генерации файла происходили какие-то нештатные события, будет предложено ознакомиться с логом.

- *Символьная информация* \
В случае если был выбран конфиг для модулей, пользователю предложат скачать отладочные символы для системных библиотек, от которых зависит его приложение, и символы ядра операционной системы. Для выполнения этой операции потребуется пароль для sudo. Кроме того, если не все зависимости были установлены, то скрипт предложит установить нужные пакеты, для этого так же потребуется пароль для sudo. В случае нештатных ситуаций пользователь получит соответствующие сообщения, а произвести скачивание символов можно будет отдельно, воспользовавшись скриптом ``debug_info.py`` (подробнее в пункте [Автоматическая загрузка отладочной информации для разделяемых библиотек](3_configs.md#debug_info)).

Затем произойдет извлечение символьной информации для скачанных модулей.

На этом настройка окончена.

Кроме командных строк будет сгенерирована заготовка конфигурационного файла *Natch*. В полученном файле описаны все возможные секции и поля с примерами заполнения, часть из которых закомментирована. При необходимости этот файл можно отредактировать -
раскомментировать нужные секции и внести актуальные значения параметров. Имя конфигурационного файла задается по умолчанию, а именно *natch.cfg*.

Полученные скрипты *run_record.sh* и *run_replay.h* применяются для работы с *Natch* для записи сценария работы виртуальной машины и воспроизведения соотетственно.

Скрипт *run_replay.sh* имеет необязательный параметр *snapshot_name*. Например, если во время записи был сохранен снэпшот с именем *state*, то запустить воспроизведение с этого момента можно либо передав скрипту параметр ``./run_replay.sh state``, либо отредактировав скрипт путем замены значения переменной *SNAPSHOT* с *record* на *state*.

В процессе работы скрипта *natch_run.py* вызывается ряд других скриптов, входящих в поставку *Natch*. Если на каком-то из этапов что-то пошло не так или пользователь отказался от какой-то опции а потом передумал, эти скрипты можно запускать самостоятельно. Все они оснащены опцией *-h* для получения справки о параметрах. Далее приведено краткое описание скриптов:

- *module_config.py* - генерирует конфигурационный файл *module.cfg*
- *debug_info.py* - скачивает символьную информацию для модулей и ядра, модифицирует *module.cfg*, на вход принимает его же.
- *symbol_info.py* - парсит символьную информацию, формирует базу символов. Так же требуется *module.cfg*.


### 4.1.1. Внесение изменений в скрипты запуска

При необходимости изменить настройки запуска инструмента можно воспользоваться входящим в поставку скриптом `change_settings.py`. Скрипт расположен в папке `utils`, однако для удобства копируется в рабочую директорию на этапе конфигурирования.

На данный момент для автозамены во всех скриптах запуска доступны два параметра: размер оперативной памяти и проброшенные порты.
Изменять их можно через параметры скрипта.

```bash
change_settings.py [-h] [-d DIRECTORY] [-m MEMORY] [-p PORTS]
```
Все параметры являются опциональными.

- Директория. Если скрипт запущен не из рабочей директории проекта, то следует указать путь к ней.
- Размер ОЗУ. Указать желаемый размер оперативной памяти, используя постфикс G или M.
- Проброшенные порты. Указать список новых портов для проброса через запятую. Прошлый список будет заменен. Если нужно отменить проброс, необходимо указать значение параметра 0. Этот параметр затрагивает не только скрипты запуска, но и основной конфигурационный файл инструмента.

Пример использования:
```bash
./change_settings.py -m 8G -p 2222,8888,4343
```


## 4.2. Определение источников пометки
### 4.2.1. Пометка файлов

*Natch* может помечать отдельные файлы в гостевой системе и отслеживать модули и функции, которые были затронуты в результате работы с ними. При этом берутся в расчет только операции чтения.

Исполняемые файлы помечаться таким способом не будут, так как они не открываются для чтения пользовательским кодом, а отображаются
прямо в адресное пространство ядерными функциями.
Аналогично не будет детектироваться работа драйвера жесткого диска с местом хранения заданного файла.

Включить плагин и задать необходимые для пометки файлы можно в основном конфигурационном файле *Natch*. Если секция *TaintFile* не была описана, для пометки файлов необходимо подключить плагин *taint_file*. Сделать это можно во время работы эмулятора командой монитора ``plugins_load taint_file``.

Плагин предоставляет набор функций, в частности, отслеживание файла включается командой ``taint_file <filename>``. Имя файла можно указывать без пути или с ним, но во втором случае он может быть не найден из-за особенностей реализации.

После этого необходимо повзаимодействовать с помеченным файлом и оценить результат с помощью команды ``natch_get_attack_surface <filename>`` или завершив работу эмулятора.

### 4.2.2. Пометка входящих сетевых пакетов

*Natch* способен помечать весь сетевой трафик, который приходит в виртуальную машину извне.
Пометка полностью локального трафика пока не поддерживается.

Для управления пометкой пакетов используется секция *[Ports]* конфигурационного файла (подробнее в пункте [Основной конфигурационный файл](3_configs.md#main_config) секция **Ports**).

Пакеты помечаются целиком, вместе с заголовком второго уровня.
Возможны следующие варианты работы:

* Помечать все входные пакеты. ip_protocol=-1 + (dst=-1 или src=-1)
* Помечать все UDP-пакеты. ip_protocol=17
* Помечать все TCP-пакеты. ip_protocol=6 + (dst=-1 или src=-1)
* Помечать все HTTP-пакеты от внешнего веб-сервера. ip_protocol=6 + src=80
* Помечать все ICMP-пакеты. ip_protocol=1


## 4.3. Запуск Natch вручную

Скрипт *natch_run.py* призван упростить пользователю работу с инструментом, однако можно формировать командные строки для запуска самостоятельно. Пример конфигурационного файла *Natch* можно взять из документации.

Запускать инструмент для работы следует в режиме детерминированного воспроизведения.


### 4.3.1. Подготовка первого запуска Natch вручную

Инструмент *Natch* агрегирован в плагине *natch*, который подключается к Qemu.

Прежде чем перейти к описанию скрипта, рассмотрим опцию для подключения конфигурационного файла плагина *natch*.
- *config* \
Задает файл конфигурации инструмента (подробнее в пункте [Основной конфигурационный файл](3_configs.md#main_config)).

Пример командной строки, отвечающей за подключение плагина с опцией *config*:
```
-plugin natch,config=natch.cfg
```

Пример командной строки для запуска *Natch*:

```
./qemu-system-x86_64 -hda debian.qcow2 -m 6G -monitor stdio -netdev user,id=net0 -device e1000,netdev=net0 \
-os-version Linux -plugin natch,config=natch.cfg
```

При первом ручном запуске *Natch* произойдет генерация конфигурационного файла *task.cfg*. Следует дождаться завершения работы эмулятора, после чего можно  сформировать строки запуска для детерминированного воспроизведения и запускать его для работы.

Так же при необходимости следует запустить остальные скрипты, входящие в поставку инструмента, которые были описаны выше.


### 4.3.2. Запуск Natch с использованием детерминированного воспроизведения

Детерминированное воспроизведение состоит и двух фаз: запись и воспроизведение. Во время записи необходимо выполнить сценарий, который будет анализироваться во время следующих запусков в режиме воспроизведения.

При использовании скрипта для генерации командных строк, строки запуска для записи и воспроизведения будут получены автоматически: *run_record.sh* для записи и *run_replay.sh* для воспроизведения. В нашем случае необходимо сформировать такие строки самостоятельно.

Непосредственно работа с инструментом *Natch* никак не изменится при использовании детерминированного воспроизведения. Изменения коснутся лишь строки запуска самого эмулятора.

Ниже приведен пример строк запуска эмулятора в режимах записи и воспроизведения.

Пример командной строки для записи работы:

```text
./qemu-system-x86_64 -m 4G \
-icount shift=5,rr=record,rrfile=replay.bin \
-drive file=debian10.qcow2,if=none,snapshot,id=img-direct \
-drive driver=blkreplay,if=none,image=img-direct,id=img-blkreplay \
-device ide-hd,drive=img-blkreplay \
-netdev user,id=net0 \
-device e1000,netdev=net0 \
-object filter-replay,id=replay,netdev=net0 \
-monitor stdio \
```

Пример командной строки для воспроизведения работы:

```text
./qemu-system-x86_64 -m 4G \
-icount shift=5,rr=replay,rrfile=replay.bin \
-drive file=debian10.qcow2,if=none,snapshot,id=img-direct \
-drive driver=blkreplay,if=none,image=img-direct,id=img-blkreplay \
-device ide-hd,drive=img-blkreplay \
-netdev user,id=net0 \
-device e1000,netdev=net0 \
-object filter-replay,id=replay,netdev=net0 \
-monitor stdio \
-plugin natch,config=natch.cfg \
```

